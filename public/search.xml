<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重回基础之http协议笔记系列（四）：HTTP进阶特性</title>
      <link href="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/"/>
      <url>/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之HTTP协议系列主要是基于对 <strong>极客时间的《透视HTTP协议》课程</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="HTTP中的实体数据"><a href="#HTTP中的实体数据" class="headerlink" title="HTTP中的实体数据"></a>HTTP中的实体数据</h2><h3 id="数据类型与压缩"><a href="#数据类型与压缩" class="headerlink" title="数据类型与压缩"></a>数据类型与压缩</h3><p>HTTP中标记实体数据类型使用  <strong>MIME type</strong>，  形式是“<strong>type/subtype</strong>”的字符串 。 这是借鉴了电子邮件系统里的”多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。</p><p> HTTP 里经常遇到的几个类别：</p><ul><li>text ： 即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等</li><li>image：即图像文件，有 image/gif、image/jpeg、image/png 等 </li><li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等 </li><li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据 </li></ul><p><strong>MIME type</strong> 只是规定了数据的类型，但在传输过程中为了节省带宽故还会压缩数据，故还有一个 *<em>Encoding type *</em>，表示数据使用什么压缩格式。</p><p>HTTP中常见的压缩格式：</p><ul><li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式； </li><li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip； </li><li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。 </li></ul><blockquote><p><strong>HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“内容协商”。</strong></p></blockquote><img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/5191bce1329efa157a6cc37ab9e789b9.png" class=""> <p> <strong>Accept 字段标记的是客户端可理解的 MIME type</strong>，用“,”做分隔符列出多个类型，让服务器有更多的选择余地； <strong>Accept-Encoding 字段标记的是客户端支持的压缩格式</strong> ,也是用“,”做分隔符列出多个类型.</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/html,application/xml,image/webp,image/png</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</span></pre></td></tr></table></figure><p>与客户端相对应的是服务器会在响应报文里使用 <strong>Content-Type 告诉实体数据的真实类型</strong> , 使用<strong>Content-Encoding</strong> 告诉数据实际的压缩格式。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span></pre></td></tr></table></figure><blockquote><p> 不过Accept-Encoding， Content-Encoding这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。 </p></blockquote><h3 id="数据语言与编码"><a href="#数据语言与编码" class="headerlink" title="数据语言与编码"></a>数据语言与编码</h3><p>HTTP中标记实体数据语言 使用<strong>语言类型</strong>，形式为 “<strong>type-subtype</strong> ”的字符串。如下所示：</p><ul><li>en 表示任意的英语 <ul><li>en-US 表示美式英语</li><li>en-GB 表示英式英语</li></ul></li><li>zh-CN 表示汉语</li></ul><p>语言类型固定了实体数据的语言类型，与此同时使用 <strong>字符集</strong> 来处理实体数据的自然语言转换相关内容。常用的有如下所示：</p><ul><li>UTF-8</li><li>ASCII</li><li>Unicode </li></ul><blockquote><p> <strong>HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言与编码进行“内容协商”。</strong> </p></blockquote> <img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/0e9bcd6922fa8908bdba79d98ae5fa10.png" class=""> <p> <strong>Accept-Language</strong> 字段<strong>标记了客户端可理解的自然语言</strong>，也允许用“,”做分隔符列出多个类型；</p><p> 字符集表示<strong>实体数据的编码方式</strong>, HTTP 里使用的请求头字段是 <strong>Accept-Charset</strong> 。 字符集 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Language</span>: zh-CN, zh, en</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Charset</span>: gbk, utf-8</span></pre></td></tr></table></figure><p>与客户端相对应的服务器会在 响应报文里用头字段 <strong>Content-Language 告诉客户端实体数据使用的实际语言类型</strong> ， 但响应头里却没有对应的 <strong>Content-Charset</strong>，而是在 <strong>Content-Type</strong> 字段的数据类型后面用“charset=xxx”来表示 。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Language</span>: zh-CN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span></pre></td></tr></table></figure><blockquote><p> 不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。 </p></blockquote><h3 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h3><p> 在 HTTP 协议里用  一种特殊的“q”参数表示权重来设定优先级 ，该字段通常使用在 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候 。</p><p> 权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/html,application/xml;q=0.9,*/*;q=0.8</span></pre></td></tr></table></figure><p> 内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">###这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Encoding,User-Agent,Accept</span></pre></td></tr></table></figure><h2 id="HTTP传输大文件"><a href="#HTTP传输大文件" class="headerlink" title="HTTP传输大文件"></a>HTTP传输大文件</h2><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p> 浏览器在发送请求时都会带着“<strong>Accept-Encoding</strong>”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“<strong>Content-Encoding</strong>”响应头里，再把原数据压缩后发给浏览器。</p><p><strong>但这种方式仅对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小</strong>。</p><blockquote><p> Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。 </p></blockquote><h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p><strong>含义</strong>：大文件（图片，音频等）分解成多个小块， 把这些小块分批发给浏览器，浏览器收到后再组装复原。</p><p> 这种“<strong>化整为零</strong>”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“<strong>Transfer-Encoding: chunked</strong>”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。 </p><p>分块传输同样 用于“<strong>流式数据</strong>”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“<strong>Content-Length</strong>”里给出确切的长度，所以也只能用 chunked 方式分块发送。 </p><blockquote><p> “Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的 ，响应报文长度要么是已知的，要么是未知的。</p></blockquote><p> 分块传输的编码规则 ：</p><ol><li>每个分块包含两个部分，长度头和数据块；</li><li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li><li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li><li>最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。 </li></ol><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>分块传输可以轻松的收发大文件，但针对某些情况仍然无法解决，比如你在看视频的时候拖动滚动条，这实际上获取一个大文件其中的片段数据，而分块传输是将整个数据传输，并不能满足这个需求。</p><p>HTTP协议为了满足该需求，提出了 <strong>范围请求</strong>的概念，允许客户端在请求头里使用专用字段来表示获取文件的一部分，相当于是客户端的 <strong>化整为零</strong>。</p><p>范围请求不是Web服务器必备的，所以Web服务器必须明确使用字段“<strong>Accept-Ranges: bytes</strong>”明确告知客户端 。</p><p> 请求头 <strong>Range</strong> 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。 格式比较灵活，如下所示。</p><ul><li>0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；</li><li>“10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；</li><li>“-1”是文档的最后一个字节，相当于“99-99”；</li><li>“-10”是从文档末尾倒数 10 个字节，相当于“90-99”。 </li></ul><p>服务器收到 <strong>Range</strong> 字段请求后，会进行以下几个步骤。</p><ol><li>检查范围是否合法，若否则返回 416（ 范围请求有误 ）。</li><li>若正确，则读取文件片段，返回 206 （原数据的一部分）。</li><li>添加一个响应头： <strong>Content-Range</strong> , 诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length“ .</li><li>发送数据了，直接把片段用 TCP 发给客户端 </li></ol><h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</p><p><strong>这种情况需要使用一种特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。</strong></p><img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/fffa3a65e367c496428f3c0c4dac8a37.png" class="" title="多段数据"><p>每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。</p><h2 id="HTTP的连接管理"><a href="#HTTP的连接管理" class="headerlink" title="HTTP的连接管理"></a>HTTP的连接管理</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p> <strong>含义</strong>：客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态， 每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接 ，所以就被称为“短连接”。 </p><h4 id="短连接的缺点"><a href="#短连接的缺点" class="headerlink" title="短连接的缺点"></a>短连接的缺点</h4><p>因为在TCP协议中，建立连接和关闭连接都需要非常昂贵的操作。TCP建立连接需要三次握手，发送3个数据包，需要1个RTT（<strong>SYN-SYN,ACK-ACK</strong>）； 关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT（<strong>客户端FIN-服务端ACK-服务端FIN-客户端ACK</strong>）。 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT（<strong>请求-服务端ACK-响应-客户端ACK</strong>）。</p><p> 浪费的时间就是“3÷5=60% 。</p><blockquote><p> RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。 </p></blockquote><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p> 针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式 ，也称之为 “持久连接”、“连接保活”、“连接复用”。 长连接的思路主要参考了 <strong>成本均摊</strong> ，虽然不能直接改善TCP的连接效率，但基于分母效应，每个请求-应答的浪费时间就会大大缩短。</p><h4 id="长连接的缺点"><a href="#长连接的缺点" class="headerlink" title="长连接的缺点"></a>长连接的缺点</h4><p> TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源 。</p><p>长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。 </p><ul><li>客户端<ul><li>请求头里加上<strong>Connection: close</strong> </li></ul></li><li>服务器（ 服务器端通常不会主动关闭连接 ，但会通过一些策略）<ul><li>Nginx 使用“<strong>keepalive_timeout</strong>”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。 </li><li>使用“<strong>keepalive_requests</strong>”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。 </li></ul></li></ul><h3 id="长连接和短连接的区别"><a href="#长连接和短连接的区别" class="headerlink" title="长连接和短连接的区别"></a>长连接和短连接的区别</h3><p><img src="https://static001.geekbang.org/resource/image/57/b4/57b3d80234a1f1b8c538a376aa01d3b4.png" alt="img"> </p><blockquote><p>长连接对性能的改善比较明显，故HTTP/1.1中的连接默认都是开启长连接。</p></blockquote><h3 id="连接相关的头字段"><a href="#连接相关的头字段" class="headerlink" title="连接相关的头字段"></a>连接相关的头字段</h3><p>请求头中也可以明确使用长连接机制，使用的字段 <strong>Connection</strong>，值为 <strong>keep-alive</strong>。</p><blockquote><p>  不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“Connection: keep-alive”字段 </p></blockquote><h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><p> “队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。 HTTP固定报文是<strong>一发一收</strong>，这就形成了先进先出的一个串行队列。如果队首的请求过慢，队列里的请求都会跟着变慢。</p><img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/6a6d30a89fb085d5f1773a887aaf5572.png" class="" title="队头阻塞">  <h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><blockquote><p> 因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决 ，只能缓解。</p></blockquote><ul><li><p>并发连接</p><p>同时对一个域名发起多个长连接，用数量来解决质量的问题。 但这种方式会造成DDOS攻击，所有客户端都希望自己快建立长连接的话，服务器根本就扛不住。</p></li><li><p>域名分片</p></li></ul><p>将域名拆分为多个域名指向同一台服务器， 还是用数量来解决质量的思路。比如 shard1.xxx.com、shard2.xxx.com，而这些域名都指向同一台服务器 <a href="http://www.xxx.com。" target="_blank" rel="noopener">www.xxx.com。</a></p><blockquote><p> 浏览器限制一个域名最多6个连接，域名分2片，那么浏览器就可以同时建立12个连接，显然就能够并发更多请求，获取数据也就快了。 </p></blockquote><h2 id="HTTP的重定向和跳转"><a href="#HTTP的重定向和跳转" class="headerlink" title="HTTP的重定向和跳转"></a>HTTP的重定向和跳转</h2><p>在某一个页面中发起一个新的 HTTP 请求，获取响应报文后就会切换显示内容，渲染出新 URI 指向的页面这样的动作称之为<strong>主动跳转</strong>，还有一类跳转是由服务器来发起的，浏览器使用者无法控制，相对地就可以称为“被动跳转”，这在 HTTP 协议里有个专门的名词，叫做<strong>重定向</strong>。</p><h3 id="重定向的过程"><a href="#重定向的过程" class="headerlink" title="重定向的过程"></a>重定向的过程</h3><p>301称之为永久重定向，302称之为临时重定向。</p><p>这两个状态码都会搭配“<strong>Location</strong>”响应头字段，<strong>它标记了服务器要求重定向的 URI</strong>，当浏览器接收到301或302的状态码时，会检查响应头里有没有“Location”。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求。</p><p>重定向报文中还可以使用 *<em>Refresh *</em>字段实现延时重定向，（refresh：5；url=xxx）。</p><p>与跳转相关的还有一个<strong>Referer</strong>和<strong>Referrer-Policy</strong>（前者是一个拼写错误），表示浏览器跳转的来源，可用于统计分析额防盗链。</p><blockquote><p>Location可以使用使用绝对 URI，也可以使用相对 URI。在重定向时如果只是在站内跳转，你可以放心地使用相对 URI。但如果要跳转到站外，就必须用绝对 URI。</p></blockquote><h3 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h3><ul><li>301： 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。<ul><li>域名、服务器、网站架构发生了大幅度的改变</li></ul></li><li>302 ：俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。<ul><li>系统维护</li><li>服务降级：双11，把不重要的功能入口暂时关闭，保证核心服务能够正常运行</li></ul></li><li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；</li><li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；</li><li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。</li></ul><blockquote><p>后3个状态码浏览器的接受程度较低，有的浏览器可能不支持，开发需谨慎。</p></blockquote><h3 id="重定向到应用场景"><a href="#重定向到应用场景" class="headerlink" title="重定向到应用场景"></a>重定向到应用场景</h3><ul><li>资源不可用（域名变更，服务器变更，网站改版等）</li><li>避免重复（多个网址都跳转到一个 URI，增加访问入口的同时还不会增加额外的工作量）</li></ul><h3 id="重定向的相关问题"><a href="#重定向的相关问题" class="headerlink" title="重定向的相关问题"></a>重定向的相关问题</h3><ul><li>性能损耗：重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次，站内重定向还好说，可以长连接复用，站外重定向就要开两个连接</li><li>循环跳转：如果重定向的策略设置欠考虑，可能会出现“A=&gt;B=&gt;C=&gt;A”的无限循环，故HTTP协议规定浏览器必须有检测循环跳转到能力。</li></ul><h2 id="HTTP的Cookie机制"><a href="#HTTP的Cookie机制" class="headerlink" title="HTTP的Cookie机制"></a>HTTP的Cookie机制</h2><p>由于HTTP协议是无状态的，所以服务器不会记住每次请求过来的客户端。所以服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出是哪个客户端。</p><h3 id="Cookie-的工作过程"><a href="#Cookie-的工作过程" class="headerlink" title="Cookie 的工作过程"></a>Cookie 的工作过程</h3><p>使用set-cookie来给客户端小纸条，客户端每次使用cookie字段来携带小纸条告诉服务器。</p><img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/9f6cca61802d65d063e24aa9ca7c38a4.png" class="" title="cookie的工作机制"><blockquote><p>Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。</p></blockquote><h3 id="Cookie的属性"><a href="#Cookie的属性" class="headerlink" title="Cookie的属性"></a>Cookie的属性</h3><blockquote><p>Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息。所以，就需要在“key=value”外再用一些手段来保护，防止外泄或窃取，这些手段就是 Cookie 的属性。</p></blockquote><ul><li><p>Cookie 的生存周期</p><ul><li><strong>Expires</strong>：过期时间，用的是绝对时间点，可以理解为“截止日期”（deadline）</li><li><strong>Max-Age</strong>：相对时间，单位是秒，览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。</li></ul><blockquote><p>两者可同时出现，数据可以不一致，浏览器优先采用max-age；</p><p>若不指定，则为会话Cookie，一旦浏览器关闭就失效。</p></blockquote></li><li><p>Cookie 的作用域</p><ul><li><code>Domain</code>和<code>Path</code>指定了Cookie所属的<strong>域名</strong>和<strong>路径</strong>，浏览器在发送Cookie前会从URI中提取host和path部分，对比Cookie的属性。如果不满足条件，就不会在请求头里发送Cookie。</li><li>通常<code>Path</code>就用一个 <code>/</code> 来直接省略，表示该域名下的所有路径都允许使用Cookie，让服务器自己去挑选。</li></ul></li><li><p>Cookie的安全性</p><ul><li><strong>HttpOnly</strong>：此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</li><li><strong>SameSite</strong>：可以防范”跨站请求伪造”（XSRF）攻击，设置成 <code>SameSite = Strict</code>可以严格限定Cookie不能随着跳转链接跨站发送，而<code>SameSite = Lax</code>则略宽松一点，允许GET/HEAD请求，但禁止POST请求。 </li><li><strong>Secure</strong>：表示这个Cookie仅能用HTTPS协议进行传输，明文的HTTP协议会禁止发送。但Cookie本身是不加密的，浏览器还是以明文显示。</li></ul></li></ul><h3 id="Cookie的应用"><a href="#Cookie的应用" class="headerlink" title="Cookie的应用"></a>Cookie的应用</h3><ul><li>身份识别 ：保存用户的登录信息，实现会话事务。</li><li>广告跟踪：这种Cookie不是由访问的主站存储的，所以又叫”第三方存储”。</li></ul><h2 id="HTTP的缓存控制"><a href="#HTTP的缓存控制" class="headerlink" title="HTTP的缓存控制"></a>HTTP的缓存控制</h2><p> 链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高 ，故需要缓存来避免通信成本，节省带宽，加快网络速度。基于“请求 - 应答”模式的特点，可以大致分为客户端缓存和服务器端缓存 。</p><p>浏览器请求过程：</p><img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/a1968821f214df4a3ae16c9b30f99a5b.png" class="" title="缓存请求"><h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3><p> 服务器标记资源有效期使用的头字段是“<strong>Cache-Control</strong>”，里面的值“<strong>max-age=30</strong>”就是资源的有效时间 。</p><blockquote><p>max-age的有效时间指的是 时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。 </p></blockquote><p><strong>Cache-Control</strong> 还有其他的值属性来如何指定缓存：</p><ul><li>no-store：<strong>不允许缓存</strong>，用于某些经常变化频繁的数据，例如秒杀。</li><li>no-cache：<strong>可以缓存</strong>，但每次使用前<strong>必须</strong>去服务器验证是否过期或新版本。（<strong>使用缓存前必须验证</strong>）</li><li>must-revalidate：缓存不过期就可以继续使用，但过期了还想用就去服务器验证是否可以继续使用。（<strong>缓存失效后必须验证</strong>）</li></ul><h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><p> 其实不止服务器可以发“<strong>Cache-Control</strong>”头，浏览器也可以发“<strong>Cache-Control</strong>”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。 </p><p>当在浏览器中进行 <strong>刷新</strong> 操作时，浏览器会在请求头加入 <strong>Cache-Control:max-age=0 ** 或</strong>Cache-Control: no-cache**  ， 这里的意思就是指 和服务器沟通需要最新的数据。</p><p>当在浏览器中进行 <strong>前进或后退</strong> ，打开开发者工具可以看到  状态码后显示<strong>from disk cache</strong> ，意思是没有发送网络请求，读取磁盘上的缓存。</p><h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><p>浏览器用“<strong>Cache-Control</strong>”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。 </p><ol><li>先发送一个HEAD请求，获取资源的修改时间等元信息，将得到的信息与缓存数据对比；</li><li>若没有改动则使用缓存信息，若改动则再发送get请求。</li></ol><blockquote><p>这样的做法需要发送2个请求，成本太高。所以在请求头上加上 <strong>If</strong>开头的 条件请求字段，用来检查资源是否过期，把两个请求才能完成的工作合并到一个请求中。</p></blockquote><p>条件请求共有以下几个头字段供使用</p><ul><li><p><strong>if-Modified-Since</strong> ：第一次响应返回的 <strong>Last-modified</strong></p></li><li><p><strong>If-None-Match</strong> ：第一次响应返回的 <strong>ETag</strong> </p></li><li><p><strong>Last-modified</strong> ：文件最后修改时间</p></li><li><p><strong>ETag</strong> ： “实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题 </p><ul><li>强ETag： 要求资源在字节级别必须完全相符 </li><li>弱ETag： 弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化 <ul><li>HTML 里的标签顺序调整，或者多了几个空格 </li></ul></li></ul><p>整个流程如图所示：</p></li></ul><img src="/keepmoving/2020/05/06/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/b239d0804be630ce182e24ea9e4ab237.png" class="" title="条件请求">]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之HTTP协议笔记系列（三）：HTTP基本结构与特点</title>
      <link href="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/"/>
      <url>/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之HTTP协议系列主要是基于对 <strong>极客时间的《透视HTTP协议》课程</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ol><li>起始行（start line）：描述请求或响应的基本信息；</li><li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li><li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li></ol><blockquote><p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p></blockquote><img src="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/62e061618977565c22c2cf09930e1d3c.png" class="" title="报文格式"><p>示例如下图所示：</p><img src="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/b191c8760c8ad33acd9bb005b251a2df.png" class="" title="报文示例"><p>http协议对header的大小没有限制，但各个web服务器都会做相对的限制，避免影响效率。</p><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>含义：描述客户端想如何操作服务端的资源。由三部分构成，如下</p><ul><li>METHOD：请求方法，get post 等。</li><li>URI：标记了请求方法要操作的资源</li><li>VERSION：报文使用的http版本号</li></ul><p>请求行示例如下：（sp表示空格 crlf表示换行）</p><p>METHOD+SP+URI+SP+VERSION+CRLF</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>含义：描述服务器响应状态。也由三部分构成，如下</p><ul><li>VERSION：报文使用的http版本号</li><li>STATUS CODE：状态码 表示处理的结果，200-成功 500-服务器错误</li><li>REASON：作为状态码的补充说明</li></ul><p>状态示例如下：</p><p>VERSION+SP+STATUS CODE+SP+REASON+CRLF</p><h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><p>头部字段由 k-v形式组成，k-v用冒号隔开，最后用 CRLF 换行表示字段结束。</p><p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，<strong>也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</strong></p><p>头部字段以下几点需要注意：</p><ul><li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li><li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li><li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li><li>字段的顺序是没有意义的，可以任意排列不影响语义；</li><li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li></ul><p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，如图。</p><img src="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/1fe4c1121c50abcf571cebd677a8bdea.png" class="" title="请求头"><img src="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/cb0d1d2c56400fe9c9988ee32842b175.png" class="" title="响应头"><h4 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h4><p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p><ol><li>通用字段：在请求头和响应头里都可以出现；</li><li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li><li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li><li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li></ol><p><strong>Host</strong> 字段：</p><p>属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，表示告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机（应用）的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p><p><strong>User-Agent</strong> 字段：</p><p>属于请求字段，使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</p><blockquote><p>由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。</p></blockquote><p><strong>Date</strong> 字段：</p><p>属于通用字段，通常出现在响应头里，表示 HTTP 报文创建的时间，<strong>客户端可以使用这个时间再搭配其他字段决定缓存策略</strong>。</p><p><strong>Server</strong> 字段：</p><p>属于响应字段，告诉客户端当前正在提供 Web 服务的软件名称和版本号。</p><blockquote><p>非必须出现，因为这会把服务器的一部分信息暴露。</p></blockquote><p><strong>Content-Length</strong> 字段：</p><p>属于实体字段，表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式。</p><ol><li>GET：获取资源，可以理解为读取或者下载数据；</li><li>HEAD：获取资源的元信息；</li><li>POST：向资源提交数据，相当于写入或上传数据；</li><li>PUT：类似 POST；</li><li>DELETE：删除资源；</li><li>CONNECT：建立特殊的连接隧道；</li><li>OPTIONS：列出可对资源实行的方法；</li><li>TRACE：追踪请求 - 响应的传输路径。</li></ol><h3 id="GET-HEAD"><a href="#GET-HEAD" class="headerlink" title="GET/HEAD"></a>GET/HEAD</h3><ul><li><p>GET 获取服务器上的资源（图片，文本，视频，或java动态生成的页面或其他格式的数据）；</p></li><li><p>GET 同时可搭配头字段对资源进行更细致的获取。</p><ul><li>在url后使用<strong>#</strong>号就可以获取页面后直接定位到某个标签所在的位置；</li><li>使用 <strong>If-Modified-Since</strong> 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；</li><li>使用 <strong>Range</strong> 字段就是“范围请求”，只获取资源的一部分数据。</li></ul></li><li><p>HEAD 与 GET类似，但不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。</p><ul><li>使用场景：比如想要检查一个文件是否存在或是否存在最新版本。</li></ul></li></ul><h3 id="POST-PUT"><a href="#POST-PUT" class="headerlink" title="POST/PUT"></a>POST/PUT</h3><ul><li>POST 向 URI 提交资源，数据就在body里，含义表示创建。</li><li>PUT 向 URI 提交资源，数据在body里，含义表示更新。</li></ul><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 表示删除服务器资源。</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>CONNECT 表示 <strong>要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道</strong>，这时 Web 服务器在中间充当了代理的角色。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS <strong>要求服务器列出可对资源实行的操作方法</strong>，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</p><blockquote><p>在现在前端最常用的 cors 跨域中，浏览器都是用 OPTIONS 方法发预检请求的。</p></blockquote><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE 方法多<strong>用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径</strong>。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p><h3 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h3><p>HTTP/1.1 里规定了八种方法，但没有限制不可以自定义添加方法，只要请求方和响应方能够理解即可。</p><blockquote><p>例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。</p></blockquote><h3 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h3><p>在http协议里，安全意味着不会对服务器资源进行实质的修改，幂等意味着多次执行相同的操作，结果也都是相同的。</p><ul><li>GET与HEAD都是安全与幂等的，</li><li>DELETE由于多次删除，结果也是一样所以也是幂等的。</li><li>PUT是替换或更新资源，多次更新一个资源，资源还是以第一次的为准，故也是幂等的。</li><li>POST 不是幂等的。</li></ul><h2 id="URI的组成"><a href="#URI的组成" class="headerlink" title="URI的组成"></a>URI的组成</h2><h3 id="URI基本格式"><a href="#URI基本格式" class="headerlink" title="URI基本格式"></a>URI基本格式</h3><p>URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。结构如图所示：</p><img src="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/46581d7e1058558d8e12c1bf37d30d2a.png" class="" title="uri格式"><ul><li>scheme：表示资源应该使用哪种协议来访问<ul><li>http，https，ldap，ftp</li></ul></li><li><strong>://</strong> ：表示把 scheme 和后面的部分分离开</li><li>authority：表示资源所在的主机名，通常形式为 “host：port”<ul><li>主机名以ip或域名形式（http不可省略，file可省略），端口号可省略，依据scheme使用默认的 http（80）https（443）</li></ul></li><li>path：标记资源所在位置<ul><li>URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority</li></ul></li></ul><blockquote><p>ex：file:///D:/http_study/www/</p><p>三个斜杠里的前两个属于 URI 特殊分隔符“://”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</p></blockquote><ul><li>query：表示对资源附加的额外要求，k-v格式</li></ul><h3 id="URI完整格式"><a href="#URI完整格式" class="headerlink" title="URI完整格式"></a>URI完整格式</h3><img src="/keepmoving/2020/05/04/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E7%82%B9/ff41d020c7a27d1e8191057f0e658b38.png" class="" title="uri完整格式"><p>基本格式加以下两种新增的部分</p><ul><li>身份信息：user:passwd@，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230）</li><li>片段标识符：#fragment，表示URI 所定位的资源内部的一个“锚点”，浏览器可以在获取资源后直接跳转到它指示的位置。服务器不可见。</li></ul><h3 id="URI的编码"><a href="#URI的编码" class="headerlink" title="URI的编码"></a>URI的编码</h3><p>URI 里只能使用 ASCII 码，为了URI中可以使用其他字符，引入了编码机制。对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</p><p><strong>转义规则：直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”</strong></p><blockquote><p> 空格被转义成“%20”，而中文或日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”</p></blockquote><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。</p><p>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0<del>99 不用，这样状态码的实际可用范围就大大缩小了，由 000</del>999 变成了 100~599。</p><ul><li><p>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</p><ul><li><strong>101 Switching Protocols</strong>：客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。</li></ul></li><li><p>2××：成功，报文已经收到并被正确处理；</p><ul><li><strong>204 No Content</strong>：含义与“200 OK”基本相同，但响应头后没有 body 数据。</li><li><strong>206 Partial Content</strong>：HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分；状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</li></ul></li><li><p>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</p><ul><li><p><strong>301 Moved Permanently</strong>：永久重定向，表示请求的资源永久不在，需更改uri访问</p></li><li><p><strong>302 Found</strong>：临时重定向，表示请求的资源还在，但需要暂时用另一个 URI 来访问</p><blockquote><p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。</p><p>使用场景：网站升级https，原来的http不使用，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS；网站临时维护，配置302跳转，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化。</p></blockquote></li><li><p><strong>304 Not Modified</strong>：用于If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。</p></li></ul></li><li><p>4××：客户端错误，请求报文有误，服务器无法处理；</p><ul><li><strong>400 Bad Request</strong>：表示请求报文有误，但不会明说具体错误。</li><li><strong>403 Forbidden</strong>：表示服务器禁止访问资源，原因可能多种多样。</li><li><strong>404 Not Found</strong>：表示资源在本服务器上未找到。</li><li><strong>405 Method Not Allowed</strong>：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li><li><strong>406 Not Acceptable</strong>：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li><li><strong>408 Request Timeout</strong>：请求超时，服务器等待了过长的时间；</li><li><strong>409 Conflict</strong>：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li><li><strong>413 Request Entity Too Large</strong>：请求报文里的 body 太大；</li><li><strong>414 Request-URI Too Long</strong>：请求行里的 URI 太大；</li><li><strong>429 Too Many Requests</strong>：客户端发送了太多的请求，通常是由于服务器的限连策略；</li><li><strong>431 Request Header Fields Too Large</strong>：请求头某个字段或总体太大；</li></ul></li><li><p>5××：服务器错误，服务器在处理请求时内部发生了错误。</p><ul><li><p><strong>500 Internal Server Error</strong>：服务端错误，注意不要把服务器错误信息暴露出去。</p></li><li><p><strong>501 Not Implemented</strong>：表示客户端请求的功能还不支持。</p></li><li><p><strong>502 Bad Gateway</strong>：表示服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误。</p></li><li><p><strong>503 Service Unavailable</strong>：表示服务器当前很忙，暂时无法响应服务。</p><blockquote><p>503 是一个“临时”的状态，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</p></blockquote></li></ul></li></ul><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><h3 id="灵活可拓展"><a href="#灵活可拓展" class="headerlink" title="灵活可拓展"></a>灵活可拓展</h3><p>http协议本着开放的原则在设计之初就只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以http也有这个特性。不过在网络繁忙，连接质量差的情况下，http也无法保证数据100%传输到另一端，“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据。</p><h3 id="请求-应答"><a href="#请求-应答" class="headerlink" title="请求 - 应答"></a>请求 - 应答</h3><p>请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。</p><blockquote><p>TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量，标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。</p></blockquote><p>HTTP在整个协议里没有规定任何的“状态”，客户端和服务器永远是处在一种“无知”的状态。<strong>建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。</strong></p><h3 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h3><p>明文传输是把双刃剑，不使用二进制数据，易于理解，但于此同时，也容易被他人窥视。（例如：免费wifi）</p><h3 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h3><p>明文是不安全相关联的一点，但“身份认证”和“完整性校验”这两方面 HTTP 也是欠缺的。即无法验证通信双方的身份，也不能判断报文是否被窜改。</p><h3 id="性能一般"><a href="#性能一般" class="headerlink" title="性能一般"></a>性能一般</h3><p>请求 - 应答”模式加剧了 HTTP 的性能问题，就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p><p>为了解决这个问题，就诞生出了一个专门的研究课题“Web 性能优化”，HTTP 官方标准里就有“缓存”一章（RFC7234），非官方的“花招”就更多了，例如切图、数据内嵌与合并，域名分片、JavaScript“黑科技”等等。</p><p>HTTP/2 和 HTTP/3中对此有了比较好的解决方案。</p><p><a href="https://cloud.tencent.com/developer/article/1509279" target="_blank" rel="noopener">白话http队头阻塞</a></p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之MySQL笔记系列（五）:INNODB数据页结构</title>
      <link href="/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之MySQL系列主要是基于对 <strong>极客时间的《mysql实战45讲》课程和掘金的《从根上理解mysql》小册子</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><img src="/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/16f13ee1e2dfac7c.png" class="" title="数据页结构"><table><thead><tr><th>名称</th><th>中文字</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td><code>56</code>字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td><code>26</code>字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><h2 id="数据页如何存储记录"><a href="#数据页如何存储记录" class="headerlink" title="数据页如何存储记录"></a>数据页如何存储记录</h2><p>记录进入数据页时从 <code>free space</code>中申请一个记录的存储空间划分到 <code>user records</code>，直至用完，若仍要插入则申请新的数据页，过程如图：</p><img src="/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/16a95c0fe86555ed.png" class="" title="记录进入数据页过程"><h3 id="记录头信息的相关内容解释"><a href="#记录头信息的相关内容解释" class="headerlink" title="记录头信息的相关内容解释"></a>记录头信息的相关内容解释</h3><p>现在将记录插入表中如图所示：（图中所显示的都是10进制）</p><img src="/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/16a95c10773d8cee.png" class="" title="记录再表中的表示"><ul><li>delete_mask</li></ul><p>属性标记着当前记录是否被删除，占用1个二进制位，0表示没删除，1表示已删除。</p><blockquote><p>被删除的记录还在页中，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，故所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为所谓的<code>可重用空间</code>，之后若有新纪录插入到表中，则会覆盖这些空间。</p></blockquote><ul><li>heap_no</li></ul><p>表示当前记录在页中的位置。</p><blockquote><p>每个页中都innodb都会自动插入两条虚拟记录，分别是<strong>最小记录</strong>和<strong>最大记录</strong>。他们的heap_no分别为0和1。这两条记录都是由5字节大小的<code>记录头信息</code>和8字节大小的一个固定的部分组成的（最小记录【Infimum】和最大记录【Supremum】）。他们都单独存放在 <strong>Infimum + Supremum</strong>的部分中，而不存在 <strong>User Records</strong>。</p></blockquote><ul><li>next_record</li></ul><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</p><blockquote><p>比方说第一条记录的<code>next_record</code>值为<code>32</code>，意味着从第一条记录的真实数据的地址处向后找<code>32</code>个字节便是下一条记录的真实数据。</p><p><strong><em>Infimum记录（也就是最小记录）</em></strong> 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <strong>*Supremum记录（也就是最大记录）</strong>。</p></blockquote><img src="/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/16a95c1084c440b4.png" class="" title="next_record示意图"><p><strong>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</strong></p><h3 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h3><p>innodb是按照如下步骤存放页目录数据，页目录的单位是 slot。</p><ol><li><p>innodb将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</p></li><li><p>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</p></li><li><p>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>，也就是<code>页目录</code>（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为<code>槽</code>（英文名：<code>Slot</code>），所以这个页面目录就是由<code>槽</code>组成的。</p></li></ol><blockquote><p>注意：每个分组中的记录条数是有规定的：</p><ul><li>对于最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，</li><li>最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，</li><li>剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。</li></ul></blockquote><p>如图所示：</p><img src="/keepmoving/2020/04/27/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-INNODB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/16a95c10f2e61ad5.png" class="" title="页目录与记录"><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在<code>页目录</code>中<strong>新增一个<code>槽</code>来记录这个新增分组中最大的那条记录</strong>的偏移量。</li></ul><p>数据页中查找指定主键值的记录的过程分为两步：</p><ul><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li></ul><h3 id="Page-Header（页面头部）"><a href="#Page-Header（页面头部）" class="headerlink" title="Page Header（页面头部）"></a>Page Header（页面头部）</h3><h3 id="File-Header（文件头部）"><a href="#File-Header（文件头部）" class="headerlink" title="File Header（文件头部）"></a>File Header（文件头部）</h3><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之HTTP协议笔记系列（二）：网络分层模型与域名里的门道</title>
      <link href="/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/"/>
      <url>/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之HTTP协议系列主要是基于对 <strong>极客时间的《透视HTTP协议》课程</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h2><img src="/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/2b8fee82b58cc8da88c74a33f2146703.png" class="" title="tcp&#x2F;ip协议栈"><ul><li>TCP/IP 协议总共有四层，自下而上，每一层支撑上层，又被下层支撑着。</li><li>第一层是”链路层”（link layer），负责在以太网，WIFI这样的底层网络发送数据包，工作在网卡这个层次，使用MAC地址来标记网络上的设备，所以也可叫MAC层。<ul><li>mac层的传输单位是帧</li></ul></li><li>第二层叫“网际层”，IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址（把 MAC 编号转换成了四位数字），把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。<ul><li>ip层的传输单位是包</li></ul></li><li>第三层叫“传输层”（transport layer），这个层次协议的职责是<strong>保证数据在 IP 地址标记的两点之间“可靠”地传输</strong>，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。<ul><li>tcp：有状态，需要建立连接，保证数据不丢失，连续的字节流，有先后顺序</li><li>udp：无状态，不需要建立连接，不保证数据不丢失，分散的小数据包，有序发，无序收</li><li>tcp的传输单位是段</li></ul></li><li>第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。<ul><li>http 的传输单位则是消息或报文</li></ul></li></ul><blockquote><p>大多数情况下传输层及以下都由操作系统负责。</p></blockquote><h2 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h2><img src="/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/3abcf1462621ff86758a8d9571c07cdc.png" class="" title="osgi协议栈"><ul><li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等。</li><li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li><li>第三层：网络层，相当于 TCP/IP 里的网际层；</li><li>第四层：传输层，相当于 TCP/IP 里的传输层；</li><li>第五层：会话层，维护网络中的连接状态，即保持会话和同步;</li><li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li><li>第七层：应用层，面向具体的应用传输数据。</li></ul><blockquote><p>OSI出现的缘由是国际标准组织（ISO）想要将各种网络协议进行统一，所以设计出了一个新的网路分层协议。仅仅作为一个参考，一个标准。</p></blockquote><h2 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h2><img src="/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/70bc19acacf2245fa841349f15cb7a6f.png" class="" title="tcp&#x2F;ip协议栈的工作"><blockquote><p>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</p></blockquote><h2 id="域名里的门道"><a href="#域名里的门道" class="headerlink" title="域名里的门道"></a>域名里的门道</h2><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><img src="/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/6b020454987543efdd1cf6ddec784bf2.png" class="" title="dns核心系统"><p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p><ul><li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li><li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li><li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com" target="_blank" rel="noopener">www.apple.com</a> 的 IP 地址。</li></ul><p>即使全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问，但全世界的用户共同访问也会导致DNS系统的压力，为了缓解核心DNS系统的访问压力，通过使用 <strong>缓存</strong> 来解决。</p><ol><li>很多大公司，网络运营商会有自己的DNS服务器，作为用户访问DNS查询的代理，代替用户访问核心DNS系统。这些野生服务器被称为“非权威域名服务器”，可以缓存之前查询的结果。<ul><li>著名的有google的8.8.8.8，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”。</li></ul></li><li>操作系统也会对DNS解析结果进行缓存，如果你之前访问过某个域名网站，那么下次再访问时，会先从操作系统里拿到对应的IP地址。<ul><li>操作系统dnscache clinet 服务进行DNS缓存的（你在任务管理器里面可以看到一个dns客户端进程）</li></ul></li><li>操作系统中还有一个”主机映射“文件，通常是一个可编辑文本，在Linux中是”/etc/hosts“，在Windows中是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录就会找这个文件。</li></ol><img src="/keepmoving/2020/04/23/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9F%9F%E5%90%8D%E9%87%8C%E7%9A%84%E9%97%A8%E9%81%93/e51df3245609880641043af65bba94ac.png" class=""><h3 id="域名用法"><a href="#域名用法" class="headerlink" title="域名用法"></a>域名用法</h3><ol><li>域名代替ip地址，更换ip就能让域名指向不同ip地址的机器。</li><li>基于域名实现的负载均衡，一个域名绑定多台主机，可通过轮询算法向服务器发起请求，实现负载均衡。</li></ol><blockquote><p>不怀好意的 DNS:</p><ol><li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li><li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li></ol></blockquote><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>比如你有一个网站要上线，你在域名注册商那里申请了abc.com,那么你的域名A记录就保存在这个域名注册商的DNS服务器上，该DNS服务器称为权威域名服务器。</p><p>当客户端访问abc.com时，先查找浏览器DNS缓存，没有则查找操作系统DNS缓存，在这一阶段是操作系统dnscache clinet 服务进行DNS缓存的（你在任务管理器里面可以看到一个dns客户端进程，就是这玩意实现缓存的），如果还是没有则查找hosts文件中的域名记录。然后依然没有的话则访问电脑上设置的DNS服务器IP，比如三大营运商的dns服务器或者谷歌的8.8.8.8，此时这一层的DNS服务器称为“野生DNS缓存服务器”，也就是非权威域名服务器。如果还是没有则非权威域名服务器会去查找 根域名服务器-顶级域名服务器-二级域名服务器-权威域名服务器 ，这样客户端就在权威域名服务器上找到了abc.com对应的IP了，这个IP可以是多个，每次客户端请求的时候域名服务器会根据负载均衡算法分配一个IP给你。当DNS缓存失效了，则重新开始新一轮的域名请求。<br>总结如下：<br>浏览器缓存-&gt;操作系统dnscache -&gt;hosts文件-&gt;非权威域名服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;二级域名服务器-&gt;权威域名服务器。<br>其中非权威域名服务器还包括LDNS（企业内网DNS服务器），三大营运商DNS，谷歌公开的DNS，微软公开的DNS等。</p><h2 id="经典面试题：键入URL会发生什么"><a href="#经典面试题：键入URL会发生什么" class="headerlink" title="经典面试题：键入URL会发生什么"></a>经典面试题：键入URL会发生什么</h2><p><a href="https://mp.weixin.qq.com/s/tZ9-BoP1Oz3K4ZapLlnopQ" target="_blank" rel="noopener">从你输入一个网址，到网页显示，其间发生了什么？</a></p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之MySQL笔记系列（四）:INNODB存储结构</title>
      <link href="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之MySQL系列主要是基于对 <strong>极客时间的《mysql实战45讲》课程和掘金的《从根上理解mysql》小册子</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="InnoDB如何存储"><a href="#InnoDB如何存储" class="headerlink" title="InnoDB如何存储"></a>InnoDB如何存储</h2><p>将数据划分为若干个页，以<strong>页</strong>作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 <strong><em>16</em></strong> KB。</p><img src="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1587394589403.jpg" class="" title="innodb 磁盘与内存交互"><h3 id="innodb行格式"><a href="#innodb行格式" class="headerlink" title="innodb行格式"></a>innodb行格式</h3><p>数据通过记录存在表中的存放方式被称为 <strong>行格式</strong> ，innodb分别有4种不同类型的行格式。</p><ul><li>Compact</li><li>Redundant</li><li>Dynamic</li><li>Compressed</li></ul><h4 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h4><img src="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/169710e8fafc21aa.jpg" class="" title="compact方式存储数据"><h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><h6 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h6><p><code>MySQL</code>支持变长字段（<code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、<code>TEXT</code>类型，<code>BLOB</code>类型），变长字段存储多少字节的数据是不固定的，所以 变长字段需要存储两部分内容：1. 真正的数据内容 2.所占字节数。</p><blockquote><p>在<code>Compact</code>行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数<strong>按照列的顺序<u>逆序</u>存放</strong>，是逆序存放！</p></blockquote><p>注意：</p><ul><li>变长字段允许存储的最大字节数（<code>M×W</code>）（m为存储字符最大值，w为字符集所占字节）超过255字节并且真实存储的字节数（<code>L</code>）超过127字节，则使用2个字节，否则使用1个字节。</li><li>变长字段长度列表中只存储值为 <strong><em>非NULL</em></strong> 的列内容占用的长度，值为 <strong><em>NULL</em></strong> 的列的长度是不储存的 。</li><li>表中所有的列都不是变长的数据类型，则不会存在变长字段长度列表。</li></ul><h6 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h6><p><code>Compact</code>行格式把存储NULL值的列统一管理起来，存储到NULL值列表。</p><blockquote><p>每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列.</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为<code>NULL</code>。</li></ul></blockquote><p>注意：</p><ul><li>表中没有允许存储 <strong><em>NULL</em></strong> 的列，则不会存在<strong><em>NULL</em></strong>值列表。</li><li><code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code>。<ul><li>1个字节 = 8位</li></ul></li></ul><h6 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h6><p>记录头信息用于描述记录，由固定的<code>5</code>个字节组成。<code>5</code>个字节也就是<code>40</code>个二进制位，不同的位代表不同的意思。</p><img src="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/169710e97718ef01.jpg" class="" title="头信息"><table><thead><tr><th><strong>名称</strong></th><th>大小（单位：bit）</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><p>除了定义的列数据外，<code>mysql</code>会为每个记录添加一些隐藏列，如下</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>DB_ROW_ID</td><td>n</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>DB_TRX_ID</td><td>y</td><td>6字节</td><td>事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>y</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>主键生成策略：优先使用用户自定义主键，若无则寻找unique列，若再无，则默认添加<strong>DB_ROW_ID</strong>隐藏列作为主键。</p><h6 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h6><p>对于 <strong><em>CHAR(M)</em></strong> 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</p><p>为了避免记录在更新 <strong><em>CHAR(M)</em></strong>类型的列时可在记录处直接更新时而不需要重新分配记录空间而造成原有记录空间造成的碎片（更新该列的值的字节长度大于原有值的字节长度而小于M个字节），变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节。</p><h4 id="redundant"><a href="#redundant" class="headerlink" title="redundant"></a>redundant</h4><p>Redundant行格式是<code>MySQL5.0</code>之前用的一种行格式。</p><img src="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/169710e99a69ba3d.png" class="" title="redundant方式存储数据"><h5 id="记录的额外信息-1"><a href="#记录的额外信息-1" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><h6 id="字段长度偏移列表"><a href="#字段长度偏移列表" class="headerlink" title="字段长度偏移列表"></a>字段长度偏移列表</h6><p><code>Redundant</code>行格式会把该条记录中所有列（包括<code>隐藏列</code>）的长度信息都按照逆序存储到`字段长度偏移列表,用两个相邻数值的差值来计算各个列值的长度。</p><h6 id="记录头信息-1"><a href="#记录头信息-1" class="headerlink" title="记录头信息"></a>记录头信息</h6><table><thead><tr><th><strong>名称</strong></th><th>大小（单位：bit）</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>n_field</td><td>10</td><td>表示记录中列的数量</td></tr><tr><td>1byte_offs_flag</td><td>1</td><td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><blockquote><p><code>Redundant</code>行格式并没有<code>NULL值列表</code>，所以设计<code>Redundant</code>行格式的大叔在<code>字段长度偏移列表</code>中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为<code>NULL</code>的依据，该比特位也可以被称之为<code>NULL比特位</code>。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的<code>NULL比特位</code>是不是为<code>1</code>，如果为<code>1</code>，那么该列的值就是<code>NULL</code>，否则不是<code>NULL</code>。</p></blockquote><h6 id="CHAR-M-列的存储格式-1"><a href="#CHAR-M-列的存储格式-1" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h6><p>只要是使用<code>CHAR(M)</code>类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和<code>M</code>的乘积。所以，使用<code>Redundant</code>行格式的<code>CHAR(M)</code>类型的列是不会产生碎片的。</p><h4 id="dynamic和compressed行格式"><a href="#dynamic和compressed行格式" class="headerlink" title="dynamic和compressed行格式"></a>dynamic和compressed行格式</h4><p>两者和<code>Compact</code>行格式挺像，只不过在处理<code>行溢出</code>数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p><img src="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/169710e9b2c2b71e.png" class="" title="dynamic和compressed行溢出的处理"><blockquote><p><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</p></blockquote><h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><h4 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h4><p>存储一个<code>VARCHAR(M)</code>类型的列，需要占用3部分存储空间：</p><ul><li>真实数据</li><li>真实数据占用字节的长度</li><li><code>NULL</code>值标识，如果该列有<code>NOT NULL</code>属性则可以没有这部分存储空间</li></ul><p><code>MySQL</code>对一条记录占用的最大存储空间是有限制的，除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，<strong>其他所有的列（不包括隐藏列和记录头信息</strong>）占用的字节长度加起来不能超过<code>65535</code>个字节。</p><p>ascii字符集下，如果该<code>VARCHAR</code>类型的列没有<code>NOT NULL</code>属性，那最多只能存储<code>65532</code>个字节的数据，因为真实数据的长度可能占用2个字节，<code>NULL</code>值标识需要占用1个字节，有 <code>NOT NULL</code>标识则最多只能存储<code>65533</code>个字节的数据。</p><h4 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h4><p>innodb用 页 为基本单位来管理存储空间，一页默认大小为16kb，即16384个字节，而一个varchar(m)最多就可存储65532个字节，就会造成数据溢出。故在<code>Compact</code>和<code>Redundant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这个过程 称之为 <strong>行溢出</strong>。</p><img src="/keepmoving/2020/04/20/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-INNODB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/169710e9aab47ea5.png" class="" title="行溢出"><blockquote><p>不只是 <strong><em>VARCHAR(M)</em></strong> 类型的列，其他的 <strong><em>TEXT</em></strong>、<strong><em>BLOB</em></strong> 类型的列在存储数据非常多的时候也会发生<code>行溢出</code>.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之HTTP协议笔记系列（一）：HTTP协议与其相关的概念</title>
      <link href="/keepmoving/2020/04/19/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/keepmoving/2020/04/19/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之HTTP协议系列主要是基于对 <strong>极客时间的《透视HTTP协议》课程</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="HTTP的发展史"><a href="#HTTP的发展史" class="headerlink" title="HTTP的发展史"></a>HTTP的发展史</h2><img src="/keepmoving/2020/04/19/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/1587313623720.jpg" class="" title="HTTP发展史"><h2 id="HTTP的相关概念"><a href="#HTTP的相关概念" class="headerlink" title="HTTP的相关概念"></a>HTTP的相关概念</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP是<strong>超文本传输协议</strong>。</p><ul><li><p>文本： HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。</p></li><li><p>超文本：文字，图片，视频和音频的混合体，最关键的是含有”超链接”，能够从一个”超文本”跳转到另一个”超文本”。</p></li><li><p>传输：参与者A与B之间的”双向协议”，数据在A和B之间传输，但并没有限制只有A和B，允许中间有”中转”，只要中间人遵循HTTP协议，不打扰数据传输，就可以添加额外功能，诸如安全验证，编码转换等等。</p></li><li><p>协议：两个及以上的参与者为”协”，对参与者的一种行为约定和规范为”议”。</p></li></ul><blockquote><p><strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、视频和音频等超文本数据的约定和规范。</strong>HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p></blockquote><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器本质上是一个http协议中的请求方，使用http协议访问网络上的各种资源。浏览器还集成了很多其他功能，html排版引擎展示页面，js来实现动画效果，开发者工具用来调试等等。</p><blockquote><p>HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。</p></blockquote><h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3><p>web服务器通常是http协议中的响应方，web服务器通常有两种：硬件和软件。</p><p>硬件：物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</p><p>软件：提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>全称是 <strong>“Content Delivery Network“</strong> 翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。（主要是作为缓存用）</p><p>CDN 也是现在互联网中的一项重要基础设施，除了基本的<strong>网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络</strong>等功能，能够成倍地“放大”源站服务器的服务能力。</p><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>爬虫是另一类 User Agent，是<strong>自动</strong>访问网络资源的程序。</p><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>WAF 是“网络应用防火墙”。与硬件“防火墙”类似，它是<strong>应用层面的“防火墙”</strong>，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP 协议实际上是<strong>一系列网络通信协议</strong>的统称。其中最核心的两个协议是TCP和IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p><ul><li><p>协议栈有4层，最上层是”应用层”，最下层是”链路层”，TCP和IP则在中间：TCP属于”传输层”，IP属于”网际层”。</p></li><li><p>IP 协议是“Internet Protocol”的缩写，主要目的是<strong>解决寻址和路由问题，以及如何在两点间传送数据包</strong>。</p></li><li><p>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<strong>可靠（保证数据不丢失）的、字节流（保证数据完整）形式的</strong>通信，是 HTTP 协议得以实现的基础。</p></li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>因为ip地址为数字形式的地址对于人来说太难记忆，于是<strong>域名系统</strong>出现了，用有意义的名字作为ip的等价替换。</p><ul><li>“域名”又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构 ，域名用“.”分隔成多个单词，级别从左到右逐级升高。</li><li>域名解析为ip 称为 域名解析</li></ul><blockquote><p>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。</p></blockquote><h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3><p>URI（Uniform Resource Identifier）： 统一资源标识符，能够唯一地标记互联网上资源。</p><p>URL（Uniform Resource Locator）：统一资源定位符，等价于“网址”，实际上是 URI 的一个子集，两者其实几乎相同，不作严格区分。</p><blockquote><p>URI 是用来标记互联网上资源的一个名字，俗称URL 由“协议名 + 主机名 + 路径”构成，俗称 URL。</p></blockquote><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。</p><ul><li>SSL/TLS是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层，相当于 HTTP+SSL/TLS+TCP/IP</li></ul><blockquote><p>SSL 的全称是“Secure Socket Layer”，当发展到 3.0 时被标准化，改名为 TLS。</p></blockquote><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理介于http协议中请求方和应答方中间，既可以转发客户端的请求，也可以转发服务器的应答。常见的有：</p><ul><li>正向代理：靠近客户端，代表客户端向服务器发送请求<ul><li>vpn</li></ul></li><li>反向代理：靠近服务器端，代表服务器响应客户端的请求<ul><li>nginx</li></ul></li></ul><p>代理能做的事情：</p><ul><li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li><li>内容缓存：暂存上下行的数据，减轻后端的压力；</li><li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li><li>数据处理：提供压缩、加密等额外的功能。</li></ul><blockquote><p>HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之MySQL笔记系列（三）：字符集与比较规则</title>
      <link href="/keepmoving/2020/04/18/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
      <url>/keepmoving/2020/04/18/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之MySQL系列主要是基于对 <strong>极客时间的《mysql实战45讲》课程和掘金的《从根上理解mysql》小册子</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="字符集与比较规则"><a href="#字符集与比较规则" class="headerlink" title="字符集与比较规则"></a>字符集与比较规则</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>计算机通过建立字符与二进制的映射关系来存储字符串，而字符集就是描述<strong>某个字符范围内的编码规则</strong>。（定义了字符的范围与映射规则）</p><img src="/keepmoving/2020/04/18/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/1587307096905.jpg" class="" title="编码与解码"><h4 id="常用的字符集"><a href="#常用的字符集" class="headerlink" title="常用的字符集"></a>常用的字符集</h4><ul><li><code>ASCII</code>字符集</li></ul><p>共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#39;L&#39; -&gt;  01001100（十六进制：0x4C，十进制：76）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#39;M&#39; -&gt;  01001101（十六进制：0x4D，十进制：77）</span></pre></td></tr></table></figure><ul><li><code>ISO 8859-1</code>字符集</li></ul><p>共收录256个字符，是在<code>ASCII</code>字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。这个字符集也有一个别名<code>latin1</code>。</p><ul><li><code>GB2312</code>字符集</li></ul><p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容<code>ASCII</code>字符集，所以在编码方式上显得有些奇怪：</p><ul><li>如果该字符在<code>ASCII</code>字符集中，则采用1字节编码。</li><li>否则采用2字节编码。</li></ul><p>这种表示一个字符需要的字节数可能不同的编码方式称为<code>变长编码方式</code>。比方说字符串<code>&#39;爱u&#39;</code>，其中<code>&#39;爱&#39;</code>需要用2个字节进行编码，编码后的十六进制表示为<code>0xB0AE</code>，<code>&#39;u&#39;</code>需要用1个字节进行编码，编码后的十六进制表示为<code>0x75</code>，所以拼合起来就是<code>0xB0AE75</code>。</p><ul><li><code>GBK</code>字符集</li></ul><p><code>GBK</code>字符集只是在收录字符范围上对<code>GB2312</code>字符集作了扩充，编码方式上兼容<code>GB2312</code>。</p><ul><li><code>utf8</code>字符集</li></ul><p>收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比方说这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#39;L&#39; -&gt;  01001100（十六进制：0x4C）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#39;啊&#39; -&gt;  111001011001010110001010（十六进制：0xE5958A）</span></pre></td></tr></table></figure><p>注意：</p><blockquote><p>utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。</p></blockquote><h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>如何比较两个字符的大小？最简单的方式是通过二进制大小来比较，但英文字母大小写本质上是相同的若通过二进制大小比较则不合适，故可先同转大写或小写再比较。<strong>同一种字符集可以有多种比较规则。</strong></p><blockquote><p>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</p></blockquote><h2 id="MySQL中支持的字符集比较规则"><a href="#MySQL中支持的字符集比较规则" class="headerlink" title="MySQL中支持的字符集比较规则"></a>MySQL中支持的字符集比较规则</h2><h3 id="MySQL中的utf8和utf8mb4"><a href="#MySQL中的utf8和utf8mb4" class="headerlink" title="MySQL中的utf8和utf8mb4"></a>MySQL中的utf8和utf8mb4</h3><p><code>MySQL</code>中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，故mysql的设计者在utf8上又划分了2个概念：</p><ul><li><code>utf8mb3（utf8）</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</li></ul><blockquote><p>常用的字符使用1～3个字节就可以表示使用utf8，但比如存储一些emoji的表情，就要使用utf8mb4。</p></blockquote><p>字符集的查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span></pre></td></tr></table></figure><p>比较规则的查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span></pre></td></tr></table></figure><h3 id="字符集和比较规则的应用"><a href="#字符集和比较规则的应用" class="headerlink" title="字符集和比较规则的应用"></a>字符集和比较规则的应用</h3><h4 id="各级别的字符集和比较规则"><a href="#各级别的字符集和比较规则" class="headerlink" title="各级别的字符集和比较规则"></a>各级别的字符集和比较规则</h4><p><code>MySQL</code>有4个级别的字符集和比较规则（若未指定，则跟随上一级），分别是：</p><ul><li>服务器级别(启动或运行)</li></ul><p><code>MySQL</code>提供了两个系统变量来表示服务器级别的字符集和比较规则：<code>character_set_server</code></p><p>和 <code>collation_server</code></p><ul><li>数据库级别(建数据库或修改时)</li></ul><p>系统变量为：<code>character_set_database</code> 和 <code>collation_database</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ALTER DATABASE 数据库名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span></pre></td></tr></table></figure><p>注意：<strong><em>character_set_database</em></strong> 和 <strong><em>collation_database</em></strong> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p><ul><li>表级别(建表或修改时)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [COLLATE 比较规则名称]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    [COLLATE 比较规则名称]</span></pre></td></tr></table></figure><ul><li>列级别（建列或修改时）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    其他列...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>字符集和比较规则是互相有联系的，故：</p><ul><li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li></ul></blockquote><h2 id="客户端和服务器通信中的字符集"><a href="#客户端和服务器通信中的字符集" class="headerlink" title="客户端和服务器通信中的字符集"></a>客户端和服务器通信中的字符集</h2><p>若客户端与服务器之间使用的字符集不一致，就会导致乱码的产生。比如客户端使用utf8进行编码，服务器使用ascii进行解码，这样就会导致服务器产生乱码。</p><h4 id="MySQL中字符集的转换"><a href="#MySQL中字符集的转换" class="headerlink" title="MySQL中字符集的转换"></a>MySQL中字符集的转换</h4><p>将收到的字符串进行a字符集进行解码，然后再使用b字符集进行编码，这个过程称之为 <strong>字符集的转换</strong>。</p><p>客户端与服务器中间的传输本质上是字符串（某种字符集编码的二进制数据），从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到3个系统变量。</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从<code>characer_set_client</code>转为<code>character_set_connection</code></td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>为了避免无谓的字符转换，通常都把 <strong><em>character_set_client</em></strong> 、<strong><em>character_set_connection</em></strong>、<strong><em>character_set_results</em></strong> 这三个系统变量设置成和客户端使用的字符集一致。MySQL提供了一条非常简便的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SET NAMES 字符集名; # 等同于同时设置上述3个变量</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之MySQL系列（二）：MySQL的启动选项和系统变量</title>
      <link href="/keepmoving/2020/04/14/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AMySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/"/>
      <url>/keepmoving/2020/04/14/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AMySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之MySQL系列主要是基于对 <strong>极客时间的《mysql实战45讲》课程和掘金的《从根上理解mysql》小册子</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="启动选项和配置文件"><a href="#启动选项和配置文件" class="headerlink" title="启动选项和配置文件"></a>启动选项和配置文件</h2><p>对于<code>MySQL</code>服务器程序，我们可以指定诸如允许同时连入的客户端数量、客户端和服务器通信方式、表的默认存储引擎、查询缓存的大小等等设置；<code>MySQL</code>客户端程序，可以指定需要连接的服务器程序所在主机的主机名或IP地址、用户名及密码等信息。</p><p>启动 <code>MySQL</code>程序时可指定启动参数，启动参数可放在命令行或配置文件。</p><h3 id="在命令行上使用选项（仅对当次启动有效）"><a href="#在命令行上使用选项（仅对当次启动有效）" class="headerlink" title="在命令行上使用选项（仅对当次启动有效）"></a>在命令行上使用选项（仅对当次启动有效）</h3><p>在命令行中指定启动选项时需要在选项名前加上<code>--</code>前缀。另外，如果选项名是由多个单词构成的，它们之间可以由短划线<code>-</code>连接起来，也可以使用下划线<code>_</code>连接起来，也就是说<code>skip-networking</code>和<code>skip_networking</code>表示的含义是相同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysqld --skip-networking #禁止各客户端使用TCP&#x2F;IP网络进行通信</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mysqld --default-storage-engine&#x3D;MyISAM #指定表的存储引擎</span></pre></td></tr></table></figure><p>故通用格式为：(<strong>选项名、=、选项值之间不可以有空白字符</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">--启动选项1[&#x3D;值1] --启动选项2[&#x3D;值2] ... --启动选项n[&#x3D;值n]</span></pre></td></tr></table></figure><p>可通过<code>--help</code>选项查看程序支持的所有启动选项以及它们的默认值。(查看<code>mysqld</code>支持的启动选项有些特别，需要使用<code>mysqld --verbose --help</code>)</p><h4 id="选项的长形式和短形式"><a href="#选项的长形式和短形式" class="headerlink" title="选项的长形式和短形式"></a>选项的长形式和短形式</h4><table><thead><tr><th>长形式</th><th>短形式</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>–host</td><td>-h</td><td>主机名</td></tr><tr><td>–user</td><td>-u</td><td>用户名</td></tr><tr><td>–password</td><td>-p</td><td>密码</td></tr><tr><td>–port</td><td>-P</td><td>端口</td></tr><tr><td>–version</td><td>-V</td><td>版本信息</td></tr></tbody></table><p>短形式只需要一个 <code>-</code>即可。</p><h3 id="配置文件中使用选项"><a href="#配置文件中使用选项" class="headerlink" title="配置文件中使用选项"></a>配置文件中使用选项</h3><p>把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。</p><h4 id="配置文件的路径"><a href="#配置文件的路径" class="headerlink" title="配置文件的路径"></a>配置文件的路径</h4><p><code>MySQL</code>程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。</p><p>在类<code>UNIX</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td>/etc/my.cnf</td><td></td></tr><tr><td>/etc/mysql/my.cnf</td><td></td></tr><tr><td>SYSCONFDIR/my.cnf</td><td></td></tr><tr><td>$MYSQL_HOME/my.cnf</td><td>特定于服务器的选项（仅限服务器）</td></tr><tr><td>defaults-extra-file</td><td>命令行指定的额外配置文件路径</td></tr><tr><td>~/.my.cnf</td><td>用户特定选项</td></tr><tr><td>~/.mylogin.cnf</td><td>用户特定的登录路径选项（仅限客户端）</td></tr></tbody></table><ul><li><code>MYSQL_HOME</code>是一个环境变量，该变量的值是我们自己设置的，表示一个路径，该路径下创建一个<code>my.cnf</code>配置文件，那么这个配置文件中只能放置关于启动服务器程序相关的选项。</li><li>两个以<code>~</code>开头的路径是用户相关的，类<code>UNIX</code> 系统中都有一个当前登陆用户的概念，每个用户都可以有一个用户目录，<code>~</code>就代表这个用户目录，不同的类<code>UNIX</code>系统的用户都可以在自己的用户目录下创建<code>.my.cnf</code>或者<code>.mylogin.cnf</code>，换句话说，不同登录用户使用的<code>.my.cnf</code>或者<code>.mylogin.cnf</code>配置文件是不同的。</li></ul><h4 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h4><p>配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来。</p><p><strong>配置文件中只能使用长形式的选项，每行只指定一个选项，<code>=</code>周围可以有空白字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[server]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(具体的启动选项...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">option1     #这是option1，该选项不需要选项值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">option2 &#x3D; value2      #这是option2，该选项需要选项值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[mysqld]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">(具体的启动选项...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">[mysqld_safe]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">(具体的启动选项...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">[client]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">(具体的启动选项...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">[mysql]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">(具体的启动选项...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">[mysqladmin]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">(具体的启动选项...)</span></pre></td></tr></table></figure><ul><li><code>[server]</code>组下边的启动选项将作用于所有的服务器程序。</li><li><code>[client]</code>组下边的启动选项将作用于所有的客户端程序。</li></ul><h4 id="特定MySQL版本的专用选项组"><a href="#特定MySQL版本的专用选项组" class="headerlink" title="特定MySQL版本的专用选项组"></a>特定MySQL版本的专用选项组</h4><p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p><h4 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h4><p>依照上表中给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。<strong>值得注意的是，如果我们在多个配置文件中设置了相同的启动选项，那以<u>最后一个配置文件</u>中的为准。</strong></p><h4 id="同一个配置文件中多个组的优先级"><a href="#同一个配置文件中多个组的优先级" class="headerlink" title="同一个配置文件中多个组的优先级"></a>同一个配置文件中多个组的优先级</h4><p>同一个命令可以访问配置文件中的多个组，比如<code>mysqld</code>可以访问<code>[mysqld]</code>、<code>[server]</code>组，如果在同一个配置文件中，出现了不同组的相同配置项，<strong>将以<u>最后一个出现的组</u>中的启动选项为准</strong>。</p><h4 id="defaults-file的使用"><a href="#defaults-file的使用" class="headerlink" title="defaults-file的使用"></a>defaults-file的使用</h4><p>该配置会导致mysql不会去默认的路径下搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#在程序启动的时候将只在&#x2F;tmp&#x2F;myconfig.txt路径下搜索配置文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mysqld --defaults-file&#x3D;&#x2F;tmp&#x2F;myconfig.txt</span></pre></td></tr></table></figure><blockquote><p>使用<code>defaults-extra-file</code>可以指定额外的配置文件搜索路径（也就是说那些固定的配置文件路径也会被搜索）。</p></blockquote><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p><strong>如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准。</strong></p><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES [LIKE 匹配的模式];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#例子</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES like &#39;max_connections&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;default%&#39;;</span></pre></td></tr></table></figure><h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><h4 id="通过启动选项设置"><a href="#通过启动选项设置" class="headerlink" title="通过启动选项设置"></a>通过启动选项设置</h4><p>对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线<code>-</code>或者下划线<code>_</code>连接起来都可以，但是它对应的系统变量的单词之间必须使用下划线<code>_</code>连接起来。</p><h4 id="服务器程序运行过程中设置"><a href="#服务器程序运行过程中设置" class="headerlink" title="服务器程序运行过程中设置"></a>服务器程序运行过程中设置</h4><p>对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器。</p><p>系统变量拥有作用范围的概念，分为以下两种。</p><ul><li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li><li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li></ul><p><strong>注意：</strong> 并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。</p><ul><li>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>。</li><li>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值。</li><li>有一些系统变量的值既具有<code>GLOBAL</code>作用范围，也具有<code>SESSION</code>作用范围，比如我们前边用到的<code>default_storage_engine</code>。</li></ul><p>在服务器启动时，会将每个全局变量初始化为其默认值（可以通过命令行或选项文件中指定的选项更改这些默认值）。然后<strong>服务器还为每个连接的客户端维护一组会话变量</strong>，客户端的会话变量在连接时使用相应全局变量的当前值初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] 系统变量名 &#x3D; 值;</span></pre></td></tr></table></figure><p>注意：</p><blockquote><p>如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是<code>SESSION</code>。</p><p>同理，<code>SHOW VARIABLES</code>语句查看的<code>SESSION</code>作用范围的系统变量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</span></pre></td></tr></table></figure><h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><p><code>MySQL</code>服务器程序中维护了好多关于程序运行状态的变量，它们被称为<code>状态变量</code>。不可设置，与系统变量相似。<code>状态变量</code>也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的，所以查看<code>状态变量</code>的语句可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式]; #默认session</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回基础之MySQL系列（一）：MySQL的运行方式</title>
      <link href="/keepmoving/2020/04/14/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/"/>
      <url>/keepmoving/2020/04/14/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>重回基础系列之MySQL系列主要是基于对 <strong>极客时间的《mysql实战45讲》课程和掘金的《从根上理解mysql》小册子</strong>的笔记整理，文章内容中或多或少会添加自己的理解，仅仅是对自己知识体系的重新认识与巩固，为避免遗忘，故记之。</p></blockquote><a id="more"></a><h2 id="MySQL的架构"><a href="#MySQL的架构" class="headerlink" title="MySQL的架构"></a>MySQL的架构</h2><img src="/keepmoving/2020/04/14/%E9%87%8D%E5%9B%9E%E5%9F%BA%E7%A1%80%E4%B9%8BMySQL%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/1586876357383.jpg" class="" title="mysql客户端与服务端的连接方式"><h2 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h2><ul><li>下载源代码自行编译安装</li><li>直接使用官方提供的安装包</li></ul><blockquote><p>windows或linux的安装请自行google</p></blockquote><h3 id="MySQL的安装目录"><a href="#MySQL的安装目录" class="headerlink" title="MySQL的安装目录"></a>MySQL的安装目录</h3><h4 id="bin目录"><a href="#bin目录" class="headerlink" title="bin目录"></a>bin目录</h4><p>bin目录一般都存放着安装程序的执行文件。</p><p>mysql服务器程序</p><ul><li><strong>mysqld</strong>：代表着<code>MySQL</code>服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。</li><li><strong>mysqld_safe</strong>：启动脚本，间接的调用<code>mysqld</code>，还会启动一个监控进程，监控进程在服务器进程挂了的时候，可以帮助重启它。另外，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志。</li><li><strong>mysql.server</strong>：启动脚本，它会间接的调用<code>mysqld_safe</code>，在调用<code>mysql.server</code>时在后边指定<code>start</code>参数就可以启动服务器程序。这个 <strong><em>mysql.server</em></strong> 文件其实是一个链接文件，它的实际文件是 <strong><em>../support-files/mysql.server</em></strong>。停止的话将<code>start</code>改为<code>stop</code>.</li><li><strong>mysql_multi</strong>：运行多个<code>MySQL</code>服务器进程。可以对每一个服务器进程的启动或停止进行监控。</li></ul><p>mysql客户端程序</p><p>启动客户端程序可使用 <strong>mysql</strong> , <strong>mysqladmin</strong> ，<strong>mysqldump</strong> ,<strong>mysqlcheck</strong>等等命令。</p><ul><li><strong>mysql</strong>：通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接收服务器的处理结果。需要一些参数配合使用。例如 <code>mysql -h主机名  -u用户名 -p密码</code> 或 <code>mysql --host=主机名  --user=用户名 --password=密码</code></li></ul><h2 id="客户端与服务端的链接过程"><a href="#客户端与服务端的链接过程" class="headerlink" title="客户端与服务端的链接过程"></a>客户端与服务端的链接过程</h2><p>服务器程序和客户端程序都是计算机中的进程，所以两者之间的通信连接本质是两个进程间的通信。支持三种通信方式。</p><ul><li>TCP/IP</li><li>命名管道和共享内存(windows)</li><li>Unix域套接字文件</li></ul><h3 id="TCP-IP（相同主机或不同主机）"><a href="#TCP-IP（相同主机或不同主机）" class="headerlink" title="TCP/IP（相同主机或不同主机）"></a>TCP/IP（相同主机或不同主机）</h3><p><code>MySQL</code>采用<code>TCP</code>作为服务器和客户端之间的网络通信协议。网络中的两个进程可以通过<code>IP地址 + 端口号</code>的方式来连接，这样进程之间就可以通过网络进行通信。<code>MySQL</code>服务器启动的时候会默认申请<code>3306</code>端口号，之后就在这个端口号上等待客户端进程进行连接。若想自定义端口，则可通过启动时指定相关端口 <code>mysqld -p端口号</code>。于此同时客户端连接时也需要通过大写P <code>-P</code>来指定。</p><h3 id="Unix域套接字文件（相同主机）"><a href="#Unix域套接字文件（相同主机）" class="headerlink" title="Unix域套接字文件（相同主机）"></a>Unix域套接字文件（相同主机）</h3><p>服务器和客户端都运行在 <em>**同一台</em> **类unix的机器上，可在启动客户端程序时指定 <code>--protocol=socket</code> 启动参数，<code>MySQL</code>服务器程序默认监听的<code>Unix</code>域套接字文件路径为<code>/tmp/mysql.sock</code>，客户端程序也默认连接到这个<code>Unix</code>域套接字文件。若想改变默认的套接字文件，则可在启动服务端程序时通过指定 <code>socket</code>参数，<code>mysqld --socket=/tmp/a.txt</code>。同样，客户端也同样需要指定相同的套接字文件才可连接成功。</p><h2 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h2><p>服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是<code>连接管理</code>、<code>解析与优化</code>、<code>存储引擎</code>。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>客户端可通过以上几种方式与服务器链接，客户端与服务器建立连接时需要携带主机信息，用户名，密码进行认证，认证成功后获取当前账户的权限，认证失败则拒绝访问。每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。</p><h3 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h3><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>MySQL处理查询请求的过程，会将刚刚处理的查询请求缓存起来，若遇到相同的请求则会直接返回结果，查询缓存可以在不同客户端之间共享。</p><blockquote><p>如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中或查询请求中包含某些系统函数（例如now函数每次获取的值也不一样）、用户自定义变量和函数、一些系统表如 mysql 、information_schema等同样也不会被缓存。</p></blockquote><p><strong>缓存失效频繁的原因</strong>：如果对缓存结果中的表进行<strong><em>结构或数据的变更</em></strong>都会导致缓存失效并删除。</p><blockquote><p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。因为查询缓存有时可以提高性能，但不得不维护缓存而造成的开销。</p></blockquote><p>MySQL提供了这种“按需使用”的方式：可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code>，这样对于默认的 SQL 语句都不使用查询缓存。对于确定使用缓存的语句使用 <code>SQL_CACHE</code>进行显示指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID &#x3D; 1；</span></pre></td></tr></table></figure><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>若没有命中缓存，客户端发送过来的请求，<code>MySQL</code>服务器首先要对请求文本进行词法分析，语法分析等操作确保sql语句是正确的。</p><ul><li><strong>词法分析</strong>：MySQL 需要识别出里面的请求文本字符串分别是什么，代表什么。</li><li><strong>语法分析</strong>：根据语法规则判断你sql语句是否满足MySQL的语法。</li></ul><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>经过语法解析之后，mysql能够确定sql具体是要做什么的。<code>MySQL</code>的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等。<strong>优化的结果就是生成一个执行计划</strong>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。可使用 <code>explain</code>语句来查看某个语句的执行计划。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>经过了查询优化之后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><blockquote><p><code>MySQL</code>服务器把数据的存储和提取操作都封装到了一个叫<code>存储引擎</code>的模块。<code>MySQL</code>提供了各式各样的<code>存储引擎</code>，不同<code>存储引擎</code>管理的表具体的存储结构可能不同，采用的存取算法也可能不同。常见的存储引擎：mysiam，innodb，memory等。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。各种不同的存储引擎向上边的<code>MySQL server</code>层提供统一的调用接口（也就是存储引擎API）。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">极客时间 mysql45讲</a></p><p><a href="">掘金 mysql小册子</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> back to basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/keepmoving/2020/02/14/Jenkins/"/>
      <url>/keepmoving/2020/02/14/Jenkins/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Jenkins是一款开源 CI&amp;CD 软件，用于<strong>自动化</strong>各种任务，包括<strong>构建</strong>、<strong>测试</strong>和<strong>部署软件</strong>。 Jenkins 支持各种运行方式，可通过<strong>系统包</strong>、<strong>Docker</strong> 或者通过一个<strong>独立的 Java 程序</strong>。 </p><p>Jenkins使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p></blockquote><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>jenkins是java开发的，启动后是一个单点进程，提供一个WEB页面进行可视化操作。</li><li>数据它直接维护在本地磁盘上，所以不需要配置数据库。</li><li>它直接网络对接GIT或者SVN这种版本管理，进行代码的更新检测以及下载。</li><li>当它检测到代码提交后，会直接在进程内完成代码的更新，并执行用户自定义的一系列CI流程。</li><li>CI流程是用户通过一个特殊格式的配置文件Jenkins file定义的，每个项目可以只定义一个Jenkins file，或者为项目下的每个分支分别定义不同的Jenkinsfile，从而实现不同的CI流程。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>  Jenkins通常作为一个独立的应用程序在其自己的流程中运行， 内置<a href="https://stackoverflow.com/questions/7213541/what-is-java-servlet" target="_blank" rel="noopener">Java servlet</a> 容器/应用程序服务器（<a href="http://www.eclipse.org/jetty/" target="_blank" rel="noopener">Jetty</a>）。  Jenkins也可以运行在不同的Java servlet容器(（如<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Apache Tomcat</a> 或 <a href="https://javaee.github.io/glassfish/" target="_blank" rel="noopener">GlassFish</a>）)中作为servlet运行。</p></blockquote><ul><li>软件环境<ul><li>Java 8—无论是Java运行时环境（JRE）还是Java开发工具包（JDK）都可以。</li></ul></li></ul><p>Jenkins可安装在多个平台下，如Docker，Windows，IOS，Linux，此处介绍安装在Linux的方式，其他请移步→<a href="https://jenkins.io/zh/doc/book/installing/" target="_blank" rel="noopener">Jenkins安装文档</a>。</p><p>在Linux下安装建议通过yum方式安装。</p><ul><li>yum的repository中默认是没有Jenkins的，需要先将Jenkins存储库添加到yum的repository。 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span></pre></td></tr></table></figure><ul><li>安装Jenkins</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">yum -y install jenkins.rpm</span></pre></td></tr></table></figure><ul><li>启动Jenkins</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">service jenkins start</span></pre></td></tr></table></figure><ul><li>访问Jenkins（默认端口8080)</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://ip:8080</span></span></pre></td></tr></table></figure><ul><li>登录Jenkins</li></ul><p>初始密码可在启动的logs下查看或在该路径下<code>/var/lib/jenkins/secrets/initialAdminPassword</code>查看。</p><ul><li>默认配置</li></ul><p>默认配置存储在<code>/etc/sysconfig/jenkins</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h3><ul><li>git（ 可通过Jenkins下载或自安装（推荐））<ul><li>用途：从服务器拉取代码</li></ul></li><li>maven（ 可通过Jenkins下载或自安装（推荐））<ul><li>用途：构建项目</li></ul></li></ul><p><strong>控制面板 ** – **Manage Jenkins</strong> – <strong>Global Tool Configuration</strong></p><p>进入对应配置项会看到三个配置项，分别是maven，jdk，git</p><p>需要填写以下配置</p><ul><li>JDK<ul><li>name：标识</li><li>JAVA_HOME：/usr/local/jdk</li></ul></li><li>Git<ul><li>name：标识</li><li>Path to Git executable：/usr/bin/git</li></ul></li><li>Maven<ul><li>Name：标识</li><li>MAVEN_HOME：/usr/share/apache-maven</li></ul></li></ul><h3 id="配置LDAP服务认证"><a href="#配置LDAP服务认证" class="headerlink" title="配置LDAP服务认证"></a>配置LDAP服务认证</h3><p><strong>系统管理-管理插件-下载Active Directory plugin</strong></p><p>系统管理-全局安全设置勾选安全， 访问控制中选择Active Directory，按需配置 点击test domain若出现success即成功。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="使用Maven构建Java应用"><a href="#使用Maven构建Java应用" class="headerlink" title="使用Maven构建Java应用"></a>使用Maven构建Java应用</h3><p>Jenkins可以构建各类应用，这里以用Maven构建Java应用为例。</p><p><strong>控制面板</strong> – <strong>新建item</strong> – <strong>构建一个maven项目</strong> – <strong>填写项目名称</strong> – <strong>确定</strong></p><blockquote><p>Tips：此处若没有构建一个maven项目需要下载一个插件： Maven Integration plugin 。</p></blockquote><p>进入配置页，主要就是配置项目的源码，构建，部署等操作。（自定义）</p><p>最上方的标签卡出现General，源码管理，构建触发器，构建环境，PreStep，Build，PostSteps，构建设置，构建后操作 选项卡。</p><p><strong>此处仅做基本配置，自定义化的配置则按需配置。</strong></p><ul><li><p>General</p></li><li><p>描述：对整个项目的配置</p></li><li><p>源码管理</p><ul><li><p>Git</p><ul><li>Repositories<ul><li>Repositories URL：项目路径（ssh://git@xxx.git）</li><li>Credentials：选择链接到仓库的凭证 </li></ul></li><li>Branches to build<ul><li>指定分支：*/develop</li></ul></li></ul><blockquote><p>Tips：</p><ul><li>此处的Credentials为需要在服务器上生成ssh key，</li><li>将Jenkins所在的服务器的公钥配置到对应的仓库下，回到 <strong>控制面板</strong> – <strong>凭据</strong> – <strong>系统</strong> – <strong>全局凭据</strong> –  <strong>添加凭据</strong> – <strong>选择SSH Username With private Key</strong> ，在Private Key下 输入私钥 ID可不填 会自动生成。UserName 和描述 作为标识。</li></ul></blockquote></li></ul></li><li><p>Build</p><ul><li>Root POM ：指定根据哪个pom进行构建</li><li>Goals and options：执行的maven命令</li></ul><blockquote><p>构建好的项目存储在 <strong>/var/lib/jenkins/workspace</strong> 路径下，在该路径下可以看到项目相关代码</p></blockquote></li><li><p>Post Steps</p><ul><li><p>选择根据哪种构建结果执行后续步骤</p><ul><li>Run only if build succeeds</li><li>Run only if build succeeds or is unstable </li><li>Run regardless of build result </li></ul></li><li><p>Add post-build step：选择添加何种方式执行构建后的操作</p><ul><li>此处选择 <strong>Send files or execute commands over SSH</strong><ul><li>Name：选择具体添加的远程服务器</li><li>Transfers<ul><li>Source file：源文件（<strong>此处填写相对路径</strong>）</li><li>Remove prefixx：相对路径下除了项目的前缀</li><li>Remote directory：远程服务器路径</li><li>Exec command ：执行的shell命令</li></ul></li></ul></li></ul><blockquote><p>Tips：1. 若没有Send file or execute commands over SSH 则需要下载插件 PUBLISH OVER SSH</p><p>2.此处选择的远程服务器需要在配置中进行配置 。 <strong>控制面板</strong> – <strong>ConfigSystem</strong> –  <strong>Publish over SSH</strong>   ，输入相关的SSH配置 勾选 <strong>Use password authentication, or use a different key</strong>。</p></blockquote></li></ul></li></ul><p>全部配置完毕之后回到 <strong>控制面板</strong>，就可以看到你配置好的项目，点击最后的一个图标进行构建，此时会在左下角出现一个进度条，点击#数字 可进入构建日志，再点击控制台输出 可查看到具体的日志。</p><p>Tomcat 脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">export</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">DATE=`date +%m%d%H%M`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">PROJECT='projectname'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">TOMCAT_HOME='/a/b/apache-tomcat-8.5.35'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">WEBAPPS='webapps'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> the project</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">echo '停止服务'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">pid=`ps -ef | grep $&#123;TOMCAT_HOME&#125;| grep -v grep | awk '&#123;print $2&#125;'`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">if [ -n "$pid" ] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">then kill -9 $pid </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">else </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">echo '服务未运行'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">fi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> backup war and zip </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">echo '备份webapp下的压缩包'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">echo $&#123;TOMCAT_HOME&#125;/$&#123;WEBAPPS&#125;/$&#123;PROJECT&#125;_$&#123;DATE&#125;.zip</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -q 表示不输出详细信息 -r表示递归处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">zip -q -r $&#123;TOMCAT_HOME&#125;/$&#123;WEBAPPS&#125;/$&#123;PROJECT&#125;_$&#123;DATE&#125;.zip  $&#123;TOMCAT_HOME&#125;/$&#123;WEBAPPS&#125;/$&#123;PROJECT&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">rm -rf $&#123;TOMCAT_HOME&#125;/$&#123;WEBAPPS&#125;/$&#123;PROJECT&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">unzip the new project</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">echo '解压新的war包'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">unzip $&#123;TOMCAT_HOME&#125;/$&#123;PROJECT&#125;.war -d $&#123;TOMCAT_HOME&#125;/$&#123;WEBAPPS&#125;/$&#123;PROJECT&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">start</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">echo '启动新WAR包'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">sh $&#123;TOMCAT_HOME&#125;/bin/startup.sh</span></pre></td></tr></table></figure><p>SpringBoot 脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将应用停止 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">stop.sh <span class="comment">#!/bin/bash </span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">echo "Stopping SpringBoot Application" </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">pid=` ps -ef | grep project | grep -v grep | awk '&#123;print $2&#125;'` </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">if [ -n "$pid" ] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">then kill -9 $pid </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">fi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">backup.sh 用于将上次构建的结果备份 <span class="comment">#!/bin/bash </span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先判断文件是否存在，如果存在，则备份 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">file="/usr/remotejenkins/xxx-0.0.1-SNAPSHOT.jar" </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">if [ -f "$file" ] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">then cp /usr/remotejenkins/xx-0.0.1-SNAPSHOT.jar /usr/backupjenkins/xx.-0.0.1-SNAPSHOT.jar.`date +%Y%m%d%H%M%S` </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">fi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">startup.sh 启动项目 <span class="comment">#!/bin/sh </span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">echo "授予当前用户权限" chmod 777 /usr/remotejenkins/xx.-0.0.1-SNAPSHOT.jar </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">echo "执行....." </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">java -jar /usr/remotejenkins/xx.-0.0.1-SNAPSHOT.jar</span></pre></td></tr></table></figure><h3 id="集成SonarQube"><a href="#集成SonarQube" class="headerlink" title="集成SonarQube"></a>集成SonarQube</h3><p>jenkins与sonar集成有两种方式，</p><ul><li>一种是在Post Steps过程中使用SonarQube Scanner分析；</li><li>二是在构建后操作中使用SonarQube analysis with Maven，相当于调用了maven的插件与sonar集成。</li></ul><h4 id="SonarQube-Scanner分析"><a href="#SonarQube-Scanner分析" class="headerlink" title="SonarQube Scanner分析"></a>SonarQube Scanner分析</h4><ol><li>点击左侧导航栏的系统管理 - 全局工具设置中的SonarQube Scanner，按需配置</li><li>回到任务列表，点击配置进入任务配置 找到标签中的Post Steps。点击Add post-build step。选择 Execute SonarQube Scanner。<ul><li>task to run ：scan （分析代码）</li><li>JDK 选择框：选择 SonarQube Scanner 使用的 JDK（注意这里必须是 JDK 不能是 JRE）</li><li>Path to project properties ：可选择的输入框，这里可以指定一个 sonar-project.properties 文件，如果不指定的话会使用项目默认的 properties 文件</li><li>Analysis properties ：输入一些配置参数用来传递给 SonarQube，这里的参数优先级高于 sonar-project.properties 文件里面的参数，所以可以在这里来配置所有的参数以替代 sonar-project.properties 文件</li><li>sonar.language：指定了要分析的开发语言（特定的开发语言对应了特定的规则）</li><li>sonar.sources：定义了需要分析的源代码位置</li><li>sonar.java.binarie：定义了需要分析代码的编译后 class 文件位置</li><li>Additional arguments：-X 是进入 SonarQube Scanner 的 Debug 模式</li><li>JVM Options：可以输入在执行 SonarQube Scanner 需要的 JVM 参数</li></ul></li></ol><h4 id="Maven插件与Sonar集成"><a href="#Maven插件与Sonar集成" class="headerlink" title="Maven插件与Sonar集成"></a>Maven插件与Sonar集成</h4><p>回到任务列表，点击配置进入任务配置 找到标签中的构建后操作。选择SonarQube analysis with Maven即可。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全测试-API设计</title>
      <link href="/keepmoving/2018/12/17/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95-API%E8%AE%BE%E8%AE%A1/"/>
      <url>/keepmoving/2018/12/17/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95-API%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>最近编写的项目进行了安全测试,为了保证接口API的安全性因此增加了API验签和API防重放。验签保证了请求数据的一致性；防重放则保证了请求数据的时效性。</p></blockquote><a id="more"></a><h2 id="api验签"><a href="#api验签" class="headerlink" title="api验签"></a>api验签</h2><pre><code>为了防止api参数被篡改,需要对请求参数进行签名。这样可以保证数据的一致性.具体做法如下:</code></pre><ol><li>首先与客户端进行加密规则的约定,客户端按照约定好的加密规则及秘钥将参数进行加密,得到签名值clientSign,并且将签名放在请求头或请求体中,发送请求给服务端.</li><li>服务端获取到请求参数,通过约定好的秘钥和加密规则进行加密(除了签名值),获取到服务端加密的签名值ServerSign.</li><li>服务端将加密的签名值ServerSign与客户端传过来的签名值clientSign进行对比,若相同则表示签名没有被篡改,若不同则表示签名被篡改. </li></ol><blockquote><p><strong>因为拦截者不清楚秘钥及加密规则所以即使获取到了请求参数并修改了参数值也无法生成正确的签名值。</strong></p></blockquote><hr><h2 id="api防重放攻击"><a href="#api防重放攻击" class="headerlink" title="api防重放攻击"></a>api防重放攻击</h2><ul><li>基于时间戳<ul><li>每次请求都会在header上添加一个时间戳的键值对,通过对时间戳与当前时间戳的比较,若两者相差时间大于了预设的时间间隔即为非法请求,一般设置60s。</li><li>缺点：若在60s之内就进行了重放攻击,则请求不能保证唯一性。</li></ul></li><li>基于随机字符串<ul><li>每次请求都会在header上添加一个字符串的键值对,每次请求过后将字符串存储到服务端上(缓存或数据库)。当请求进来时,先在服务端进行检查该字符串是否已存在,若存在则是非法请求。</li><li>缺点：大量的请求会造成服务端存储的压力,验证字符串在服务端的耗时也成正比增长。若存储在服务端上的缓存中,可通过设置过期时间来减少压力。若存储在服务端上的数据库中,可通过定时任务来减少压力。</li></ul></li></ul><blockquote><p><strong>随机字符串的一次性可解决时间戳的60s问题,时间戳可以解决随机字符串服务端压力的问题。时间戳 + 字符串 就可以只存储60s之内的随机字符串。</strong><br>参考资料：<a href="http://www.cnblogs.com/xiaochangwei/p/api.html" target="_blank" rel="noopener">API接口设计：防参数篡改+防二次请求</a></p></blockquote><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="request中流对象的重复获取"><a href="#request中流对象的重复获取" class="headerlink" title="request中流对象的重复获取"></a>request中流对象的重复获取</h3><h4 id="问题描述及分析"><a href="#问题描述及分析" class="headerlink" title="问题描述及分析"></a>问题描述及分析</h4><pre><code>前端传输数据格式为JSON,HttpServletRequest中获取JSON数据格式通过流来获取的。但是流的获取只能获取一次,在拦截器中获取之后,在Conroller层就无法进行绑定参数。</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>自定义一个类继承HttpServletRequestWrapper类,重写getInputStream方法,可以重复获取流,并且在Filter中将原本的HttpServletRequest替换为包装后的流对象,这样在拦截器中获取之后controller层也可以获取。</li><li>代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public class MyHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">private static Logger logger &#x3D; LoggerFactory.getLogger(MyHttpServletRequestWrapper.class);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    private final byte[] body;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">final static int BUFFER_SIZE &#x3D; 4096;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">public MyHttpServletRequestWrapper(HttpServletRequest request) throws IOException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">super(request);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读取输入流</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">body &#x3D; cloneInputStream(request.getInputStream());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">public BufferedReader getReader() throws IOException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">return new BufferedReader(new InputStreamReader(getInputStream()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">public ServletInputStream getInputStream() throws IOException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">final ByteArrayInputStream bais &#x3D; new ByteArrayInputStream(body);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">return new ServletInputStream() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            public int read() throws IOException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                return bais.read();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            public boolean isFinished() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                return false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            public boolean isReady() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">                return false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"> * 获取输入流</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"> * @param servletInputStream</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"> * @return</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">public byte[] cloneInputStream(ServletInputStream servletInputStream)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream byteArrayOutputStream &#x3D; null;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">byte[] buffer &#x3D; new byte[BUFFER_SIZE];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">int len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">try &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">while((len &#x3D; servletInputStream.read(buffer)) &gt; -1) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">byteArrayOutputStream.write(buffer,0,len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">byteArrayOutputStream.flush();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">&#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">logger.error(&quot;cloneInputStream exception: &quot; + e.getMessage());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">&#125;finally &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">if(byteArrayOutputStream !&#x3D; null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">try &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">byteArrayOutputStream.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">&#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">logger.error(&quot;cloneInputStream close exception: &quot; + e.getMessage());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">        return byteArrayOutputStream.toByteArray();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><blockquote><p>参考资料： <a href="https://blog.csdn.net/cstdiohao/article/details/78085288" target="_blank" rel="noopener">继承HttpServletRequestWrapper 实现request中流的重复获取</a></p></blockquote><h3 id="自定义拦截器中无法获取配置文件的值"><a href="#自定义拦截器中无法获取配置文件的值" class="headerlink" title="自定义拦截器中无法获取配置文件的值"></a>自定义拦截器中无法获取配置文件的值</h3><h4 id="问题描述及分析-1"><a href="#问题描述及分析-1" class="headerlink" title="问题描述及分析"></a>问题描述及分析</h4><pre><code>拦截器中需要获取配置文件中的值,但是通过@Value属性无法注入该值。拦截器是基于springmvc,本事并没有被spring管理,所以要将自定义的拦截器注入spring,这样方便获取spirng context上下文中的值。</code></pre><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>使用 <strong>@Bean</strong>注解将拦截器注入到Spring,这样拦截器才可以获取Spring中的值  </li><li>代码实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@EnableWebMvc</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">public class SpringMVCConfig extends WebMvcConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@Bean</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">public MyInteceptor myInterceptor() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    return new MyInteceptor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">public void addInterceptors(InterceptorRegistry registry) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    registry.addInterceptor(myInterceptor());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><blockquote><p>参考资料： <a href="https://blog.csdn.net/qq_34244429/article/details/79784412" target="_blank" rel="noopener">springboot拦截器提取@Value属性值时为空的解决方案</a></p></blockquote></li></ul><hr><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><blockquote><p>​    </p></blockquote><h3 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h3><blockquote><p>参考资料： <a href="http://einverne.github.io/post/2017/08/spring-interceptor-vs-filter.html" target="_blank" rel="noopener">Spring Interceptor vs Filter 拦截器和过滤器区别</a><br>参考资料： <a href="https://juejin.im/post/5ba3bdae6fb9a05cfc54d16d" target="_blank" rel="noopener">springboot系列文章之过滤器 vs 拦截器</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>问题收录</title>
      <link href="/keepmoving/2018/12/13/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/"/>
      <url>/keepmoving/2018/12/13/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>此文章记录工作中及学习中遇到的问题。</p></blockquote><a id="more"></a><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li>问题：如何在本地初始化项目并推送至远程仓库？ </li></ul><blockquote><p><a href="https://segmentfault.com/a/1190000009491296" target="_blank" rel="noopener">将本地项目推送到远程git新仓库</a></p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li>问题：文件流 file.mkdir 和 mkdirs的区别？</li></ul><blockquote><p>java.io.File.mkdir()：只能创建一级目录，且父目录必须存在，否则无法成功创建一个目录</p><p>java.io.File.mkdirs()：可以创建多级目录，父目录不一定存在。</p></blockquote><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul><li>问题：springboot如何集成多套MQ？</li></ul><blockquote><p> <a href="https://blog.csdn.net/qq_37608766/article/details/80912370" target="_blank" rel="noopener">Spring Boot配置多个RabbitMQ</a></p></blockquote><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li>问题：@Transactional注解失效的情况及原因</li></ul><blockquote><ol><li>在代理模式（默认设置）下，只拦截通过代理进入的外部方法调用。这意味着自调用（实际上，目标对象中的方法调用目标对象的另一个方法）在运行时不会导致实际的事务，即使调用的方法被标记<code>@Transactional</code>。</li><li>使用代理时，应仅将<code>@Transactional</code>注释应用于具有公共可见性的方法。如果使用注释 注释protected，private或package-visible方法，则<code>@Transactional</code>不会引发错误，但带注释的方法不会显示已配置的事务设置。</li></ol><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-annotations" target="_blank" rel="noopener">spring官方文档</a></p><p>原因：<a href="https://www.jb51.net/article/137255.htm" target="_blank" rel="noopener">SPRING AOP 原理</a></p></blockquote><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul><li>问题：CommandLineRunner和ApplicationRunner接口的区别</li></ul><blockquote><ol><li>ApplicationRunner 默认优先于 CommandLineRunner执行</li><li>可以使用@Order指定执行顺序 1&gt;2&gt;3</li><li>CommandLineRunner的参数是最原始的参数，没有做任何处理；ApplicationRunner的参数是ApplicationArguments，是对原始参数做了进一步的封装</li><li>CommandLineRunner、ApplicationRunner 接口是在容器启动成功后的最后一步回调（类似开机自启动）。</li></ol><p><a href="https://www.jianshu.com/p/5d4ffe267596" target="_blank" rel="noopener">CommandLineRunner或者ApplicationRunner接口</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nexus</title>
      <link href="/keepmoving/2018/12/03/Nexus/"/>
      <url>/keepmoving/2018/12/03/Nexus/</url>
      
        <content type="html"><![CDATA[<h2 id="两图介绍"><a href="#两图介绍" class="headerlink" title="两图介绍"></a>两图介绍</h2><img src="/keepmoving/2018/12/03/Nexus/23101707_yGi4.png" class="" title="不存在nexus的情况"><img src="/keepmoving/2018/12/03/Nexus/23101708_45ox.png" class="" title="存在nexus的情况"><a id="more"></a><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>节省网络资源，速度快</li><li>便于管理，加速项目搭建进程</li><li>共享内部开发的公共构件</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>软件环境</p><ul><li>JDK</li></ul></li><li><p>官网获取nexus最新版本 <a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">https://www.sonatype.com/download-oss-sonatype</a></p></li><li><p>解压下载的文件夹</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">tar -xvzf nexus-3.13.0-01-mac.tgz</span></pre></td></tr></table></figure><blockquote><p>sonatype-work为nexus的工作目录，日志文件也在其中</p></blockquote><ul><li>启动nexus</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cd /nexus-3.13.0-01/bin/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">./nexus start</span></pre></td></tr></table></figure><ul><li>访问nexus</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://服务器ip地址:8081</span></span></pre></td></tr></table></figure><blockquote><p>8081为默认端口号  默认账号：admin 默认密码：admin123</p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>登陆之后左边导航栏显示</p><ul><li><p>Search：类似Maven仓库上的搜索功能，就是从私服上查找是否有这些包。支持模糊查询。</p></li><li><p>Upload：第三方jar包上传（nexus的web界面）</p></li><li><p>Support：包含日志及数据分析</p></li><li><p>Respository</p><ul><li>blob stores：可查看文件存储 创建一个目录的话，对应文件系统的一个目录，可供仓库上传文件使用</li><li>repositories：查看仓库管理<ul><li>maven-central：maven（Java）中央库，默认从 <strong><a href="https://repo1.maven.org/maven2/" target="_blank" rel="noopener">https://repo1.maven.org/maven2/</a></strong>  拉取jar 可修改</li><li>maven-releases：私库发行版jar</li><li>maven-snapshots：私库快照（调试版本）jar</li><li>maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置 settings.xml中使用。</li><li>nuget.org-proxy：nuget（.Net）中央库，默认从 <strong><a href="https://www.nuget.org/api/v2/" target="_blank" rel="noopener">https://www.nuget.org/api/v2/</a></strong> 拉取  可修改</li></ul></li></ul><blockquote><p>仓库类型</p><ul><li><p>proxy 代理仓库：代理公共的远程仓库</p></li><li><p>hosted 宿主仓库：主要用于部署无法从公共仓库获取的构件（如 oracle 的 JDBC 驱动）以及自己或第三方的项目构件</p></li><li><p>group 仓库组：Nexus 通过仓库组的概念统一管理多个仓库，这样我们在项目中直接请求仓库组即可请求到仓库组管理的多个仓库</p><img src="/keepmoving/2018/12/03/Nexus/23101709_msGh.png" class="" title="仓库类型"></li></ul></blockquote></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="使用Maven私服"><a href="#使用Maven私服" class="headerlink" title="使用Maven私服"></a>使用Maven私服</h4><ul><li>全局配置下载依赖（即项目pom无需配置）</li></ul><ol><li>在maven的setting.xml 文件中配置私服配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>myrepconf<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!--私有库地址--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">&lt;!-- 可在nexus管理界面获取--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://服务器ip地址:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">          <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!--插件库地址--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">&lt;!-- 可在nexus管理界面获取--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://服务器ip地址:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span></pre></td></tr></table></figure><ol start="2"><li>激活上方配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--激活profile--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>myrepconf<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span></pre></td></tr></table></figure><ol start="3"><li>指定镜像代理为我们的私服</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-myself<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--*指的是访问任何仓库都使用我们的私服--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus myself<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://服务器ip地址:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span></pre></td></tr></table></figure><ul><li>单独项目下载依赖(即项目pom文件中配置)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 可在nexus管理界面获取--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://服务器ip地址:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></pre></td></tr></table></figure><h4 id="上传jar包到Maven私服"><a href="#上传jar包到Maven私服" class="headerlink" title="上传jar包到Maven私服"></a>上传jar包到Maven私服</h4><p>如果要发布自己的jar包到私服，就需要修改工程的pom.xml</p><ul><li><p>自己开发的jar包</p><ol><li>maven的setting.xml文件配置(<strong>这里配置的username和password 就是登陆web端nexus的账号密码</strong>)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>username<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>username<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span></pre></td></tr></table></figure><ol start="2"><li>pom.xml文件配置如下（<strong>这里的id为setting.xml文件中配置server标签的一致</strong>）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://服务器ip地址:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://服务器ip地址:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span></pre></td></tr></table></figure><ol start="3"><li>执行maven的deploy命令 上传到Nexus （若version不含有SNAPSHOT 则会上传到releases库中，若添加则上传到snapshots库中。/ release仓库默认不支持重复发布）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-xxx-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr></table></figure></li><li><p>第三方jar包（使用web端的upload功能）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压力测试中遇到的问题</title>
      <link href="/keepmoving/2018/11/27/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/keepmoving/2018/11/27/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>压力测试流程准备及过程中碰到的问题。</p></blockquote><a id="more"></a><h3 id="压测环境准备"><a href="#压测环境准备" class="headerlink" title="压测环境准备"></a>压测环境准备</h3><blockquote><p>服务器配置：4C16G centos7 </p></blockquote><h4 id="服务端压测准备"><a href="#服务端压测准备" class="headerlink" title="服务端压测准备"></a>服务端压测准备</h4><ul><li>安装 JDK8<blockquote><p>参考链接:<a href="https://blog.csdn.net/qq_25881261/article/details/79698252" target="_blank" rel="noopener">CentOS7下安装JDK详细过程</a></p></blockquote><h4 id="数据库压测准备"><a href="#数据库压测准备" class="headerlink" title="数据库压测准备"></a>数据库压测准备</h4></li><li>安装mysql<blockquote><p>参考链接:<a href="https://blog.csdn.net/lihao21/article/details/80692068" target="_blank" rel="noopener">CentOS 7 安装 MySQL</a></p></blockquote></li></ul><hr><h3 id="压测中遇到的问题"><a href="#压测中遇到的问题" class="headerlink" title="压测中遇到的问题"></a>压测中遇到的问题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><blockquote><ul><li>现象: <strong>POST请求的测试过程中,当多个链接对同一张表的数据进行持续更新操作,执行速度越来越慢,直至出现锁表 .日志显示 数据库出现LOCK WAIT 最终导致QPS低</strong></li><li>分析: <strong>MySQL的innodb存储引擎支持行级锁，innodb的行锁是通过给索引项加锁实现的，这就意味着只有通过索引条件检索数据时，innodb才使用行锁，否则使用表锁。</strong></li><li>解决：<strong>在相应的更新语句上添加相应的字段索引</strong></li></ul></blockquote><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><blockquote><ul><li>现象: <strong>Mysql分页语句 sql查询耗时与起始页数成正比</strong></li><li>分析: <strong>根据explain sql的结果来看,虽然使用了索引但是扫描的行数还是较大</strong></li><li>解决: <strong>优化sql 采用INNER JOIN优化 先在子查询当中获取所需数据的id,然后直接关联获取结果</strong></li></ul></blockquote><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><blockquote><ul><li>现象: <strong>Mysql count语句 sql查询耗时与记录数成正比</strong></li><li>分析: <strong>MyISAM存储引擎下,会将表的记录数保存在索引中,innodb存储引擎下并没有将该信息存储在索引中</strong></li><li>解决: <strong>不要每次都请求总记录数，这样真的会很慢，对其做缓存，显示大概的数量，用户不会在乎小的误差的</strong></li></ul></blockquote><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><blockquote><ul><li>现象：<strong>get请求中服务端CPU过高,数据库CPU正常</strong></li><li>分析：<strong>在服务器上查看了java进程的gc次数，发现FGC次数过多,查看程序代码发现在for循环中去new HashMap,并发提高的同时,java进程不断在进行GC</strong></li><li>解决：<strong>将HashMap换成实体类且在for循环外先申请引用,在循环内进行实例化(申请空间),节省栈内存的空间</strong></li></ul></blockquote><hr><h3 id="补充收录"><a href="#补充收录" class="headerlink" title="补充收录"></a>补充收录</h3><h4 id="理解explain-sql语句"><a href="#理解explain-sql语句" class="headerlink" title="理解explain sql语句"></a>理解explain sql语句</h4><blockquote><p>参考链接:<a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html" target="_blank" rel="noopener">MySQL Explain详解</a></p></blockquote><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><blockquote><p>单一索引是指索引列为一列的情况,即新建索引的语句只实施在一列上。 用户可以在多个列上建立索引，这种索引叫做复合索引(组合索引)。复合索引的创建方法与创建单一索引的方法完全一样。但复合索引在数据库操作期间所需的开销更小，可以代替多个单一索引。当表的行数远远大于索引键的数目时，使用这种方式可以明显加快表的查询速度。同时有两个概念叫做窄索引和宽索引，窄索引是指索引列为1-2列的索引,如果不特殊说明的话一般是指单一索引。宽索引也就是索引列超过2列的索引。<strong>设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有效</strong>。拥有更多的窄索引，将给优化程序提供更多的选择余地，这通常有助于提高性能。</p></blockquote><hr><blockquote><p>KEY a_b_c (a, b, c)     //创建a,b,c的复合索引</p><ul><li>索引可能会对ORDER起作用:<ul><li>ORDER BY a</li><li>ORDER BY a,b</li><li>ORDER BY a, b, c</li><li>ORDER BY a DESC, b DESC, c DESC</li></ul></li><li>索引对WHERE和ORDER都起作用：<ul><li>WHERE a = const ORDER BY b, c</li><li>WHERE a = const AND b = const ORDER BY c</li><li>WHERE a = const ORDER BY b, c </li><li>WHERE a = const AND b &gt; const ORDER BY b, c</li></ul></li><li>索引在ORDER失效:<ul><li>ORDER BY a ASC, b DESC, c DESC /* 混合的ORDER方向 */ </li><li>WHERE g = const ORDER BY b, c /* 前面的字段缺失 */ </li><li>WHERE a = const ORDER BY c /* b缺失 */</li><li>WHERE a = const ORDER BY a, d /* d 不在索引中 */</li></ul></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> optimization </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
